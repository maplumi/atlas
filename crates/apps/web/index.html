<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atlas Viewer (Web)</title>
    <link data-trunk rel="rust" data-wasm-opt="z" />
    <link data-trunk rel="copy-dir" href="assets" />
    <style>
      :root {
        --bg: #020617;
        --fg: #e2e8f0;
        --muted: #94a3b8;
        --panel-bg: #0b132b;
        --panel-border: #1f2a44;
        --section-bg: #0f172a;
        --btn-bg: #111827;
        --btn-fg: #e5e7eb;
        --btn-border: #1f2a44;
        --btn-hover-bg: #111827;
        --accent: #2563eb;
        --accent-border: #3b82f6;
        --info: #93c5fd;
        --success: #86efac;
        --warning: #fbbf24;
        --danger: #fca5a5;
        --controls-bg: rgba(15, 23, 42, 0.72);
        --controls-border: rgba(31, 42, 68, 0.90);
        --shadow: rgba(2, 6, 23, 0.55);
      }
      html[data-theme="dark"] {
        --bg: #020617;
        --fg: #e2e8f0;
        --muted: #94a3b8;
        --panel-bg: #0b132b;
        --panel-border: #1f2a44;
        --section-bg: #0f172a;
        --btn-bg: #111827;
        --btn-fg: #e5e7eb;
        --btn-border: #1f2a44;
        --btn-hover-bg: #111827;
        --accent: #2563eb;
        --accent-border: #3b82f6;
        --controls-bg: rgba(15, 23, 42, 0.72);
        --controls-border: rgba(31, 42, 68, 0.90);
        --shadow: rgba(2, 6, 23, 0.55);
      }
      html[data-theme="deep-dark"] {
        --bg: #000000;
        --fg: #f1f5f9;
        --muted: #a1a1aa;
        --panel-bg: #05070c;
        --panel-border: #141a2a;
        --section-bg: #070b14;
        --btn-bg: #0b1220;
        --btn-fg: #f1f5f9;
        --btn-border: #141a2a;
        --btn-hover-bg: #0f172a;
        --accent: #2563eb;
        --accent-border: #60a5fa;
        --controls-bg: rgba(2, 6, 23, 0.80);
        --controls-border: rgba(30, 41, 59, 0.75);
        --shadow: rgba(0, 0, 0, 0.75);
      }
      html[data-theme="light"] {
        --bg: #f8fafc;
        --fg: #0f172a;
        --muted: #475569;
        --panel-bg: #ffffff;
        --panel-border: #e2e8f0;
        --section-bg: #f1f5f9;
        --btn-bg: #ffffff;
        --btn-fg: #0f172a;
        --btn-border: #cbd5e1;
        --btn-hover-bg: #f1f5f9;
        --accent: #2563eb;
        --accent-border: #1d4ed8;
        --controls-bg: rgba(255, 255, 255, 0.80);
        --controls-border: rgba(203, 213, 225, 0.85);
        --shadow: rgba(15, 23, 42, 0.15);
        --info: #1d4ed8;
        --success: #15803d;
        --warning: #a16207;
        --danger: #b91c1c;
      }

      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: var(--bg);
        color: var(--fg);
        font-family: "Inter", "JetBrains Mono", system-ui, sans-serif;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
        display: block;
        --panel-width: 320px;
      }
      #side-panel {
        background: var(--controls-bg);
        border: 1px solid var(--controls-border);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 0 12px 24px var(--shadow);
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        height: calc(100vh - 24px);
        width: var(--panel-width);
        max-width: 600px;
        overflow-y: auto;
        overflow-x: hidden;
        transition: transform 0.2s ease, width 0.15s ease;
        z-index: 20;
      }
      #panel-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 34px;
        height: 34px;
        padding: 0;
        border-radius: 10px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        cursor: pointer;
        display: grid;
        place-items: center;
      }
      #panel-toggle:hover {
        background: var(--btn-hover-bg);
        border-color: var(--accent-border);
      }
      #panel-resize-handle {
        display: block;
        position: absolute;
        top: 10px;
        right: -6px;
        width: 12px;
        height: calc(100% - 20px);
        cursor: ew-resize;
        border-radius: 8px;
      }
      #panel-resize-handle:hover {
        background: rgba(59, 130, 246, 0.3);
      }
      #panel-resize-handle.resizing {
        background: rgba(59, 130, 246, 0.5);
      }
      .tabs {
        display: flex;
        gap: 8px;
      }
      .panel-tabs {
        display: flex;
      }
      #side-panel.collapsed {
        width: 52px !important;
        padding: 10px;
        overflow: hidden;
      }
      #side-panel.collapsed #panel-resize-handle {
        display: none;
      }
      #side-panel.collapsed .panel-tabs,
      #side-panel.collapsed .tab-page,
      #side-panel.collapsed #compact-panel-close {
        display: none;
      }
      .tab-btn {
        flex: 1;
        padding: 8px 10px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
      }
      .tab-btn.active {
        background: var(--accent);
        border-color: var(--accent-border);
      }
      .tab-page.hidden { display: none; }
      #atlas-canvas-2d,
      #atlas-canvas-3d {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
      #atlas-canvas-2d.hidden,
      #atlas-canvas-3d.hidden {
        display: none;
      }
      #map-area {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      .map-controls {
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 0;
        border: none;
        background: transparent;
        backdrop-filter: none;
        border-radius: 0;
        user-select: none;
      }
      .map-controls-row {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
        padding-bottom: 0;
        border-bottom: none;
        margin-bottom: 0;
      }
      .map-controls[data-pos="left"] {
        left: 12px;
        right: auto;
      }
      .map-controls[data-pos="right"] {
        right: 12px;
        left: auto;
      }
      .map-controls .btn {
        width: 38px;
        height: 38px;
        padding: 0;
        margin: 0;
        border-radius: 10px;
        display: grid;
        place-items: center;
        font-weight: 800;
        line-height: 1;
        background: transparent;
        border: 1px solid var(--controls-border);
        box-shadow: 0 12px 24px var(--shadow);
      }
      .map-controls .btn.active {
        border-color: var(--accent-border);
      }
      .map-controls .btn:hover {
        border-color: var(--accent-border);
        box-shadow: 0 16px 28px var(--shadow);
      }
      .map-controls .btn.small {
        width: 38px;
        height: 30px;
        font-weight: 700;
        font-size: 12px;
      }
      #map-compass {
        width: 38px;
        height: 38px;
        border-radius: 999px;
        position: relative;
        padding: 0;
      }
      #map-compass .compass-label {
        position: absolute;
        top: 6px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        font-weight: 900;
        color: var(--btn-fg);
        letter-spacing: 0.5px;
        pointer-events: none;
      }
      #compass-needle {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 2px;
        height: 13px;
        background: #ef4444;
        border-radius: 2px;
        transform-origin: 50% 100%;
        transform: translate(-50%, -100%) rotate(0deg);
        pointer-events: none;
      }
      .map-controls .hint {
        max-width: 220px;
        font-size: 12px;
        color: color-mix(in srgb, var(--fg) 80%, var(--muted));
        line-height: 1.35;
      }
      .map-controls .hint.hidden {
        display: none;
      }
      .section {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 12px;
        background: var(--section-bg);
      }
      .section h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        letter-spacing: 0.3px;
        color: var(--info);
      }
      label { display: block; margin-bottom: 8px; font-size: 13px; color: color-mix(in srgb, var(--fg) 80%, var(--muted)); }
      select, button, input[type="checkbox"] {
        font-size: 13px;
      }
      button {
        padding: 8px 10px;
        margin-right: 6px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        border-radius: 6px;
        cursor: pointer;
      }
      button.active { background: var(--accent); border-color: var(--accent-border); }
      select { width: 100%; padding: 6px; border-radius: 6px; border: 1px solid var(--btn-border); background: var(--btn-bg); color: var(--btn-fg); }
      .checkbox { display: flex; gap: 8px; align-items: center; }
      .row { display: flex; align-items: center; gap: 10px; }
      input[type="range"] { width: 100%; }
      .value { font-variant-numeric: tabular-nums; color: color-mix(in srgb, var(--fg) 80%, var(--muted)); font-size: 12px; }
      .layer-row {
        display: grid;
        grid-template-columns: 1fr 44px 1fr 1fr;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
      }
      .layer-row .mini { font-size: 11px; color: var(--muted); }

      .muted { color: var(--muted); }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      .icon {
        width: 18px;
        height: 18px;
        display: inline-block;
      }
      .icon svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .icon svg * { stroke: currentColor; }

      .compact-tabs {
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        transform: none;
        display: none;
        flex-direction: column;
        gap: 8px;
        padding: 0;
        border: none;
        background: transparent;
        backdrop-filter: none;
        border-radius: 0;
        z-index: 18;
      }
      .compact-tabs .btn {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        padding: 0;
        margin: 0;
        display: grid;
        place-items: center;
        font-weight: 800;
        border: 1px solid var(--controls-border);
        background: transparent;
        backdrop-filter: none;
        box-shadow: 0 12px 24px var(--shadow);
      }
      .compact-tabs .btn.active {
        border-color: var(--accent-border);
      }
      .compact-tabs .btn:hover {
        border-color: var(--accent-border);
        box-shadow: 0 16px 28px var(--shadow);
      }
      .compact-close {
        display: none;
        position: absolute;
        top: 12px;
        right: 12px;
        width: 32px;
        height: 32px;
        border-radius: 8px;
        font-weight: 700;
        z-index: 30;
      }

      @media (max-width: 900px) {
        #side-panel {
          width: min(92vw, 380px);
          transform: translateX(calc(-100% - 24px));
        }
        #side-panel.compact-open {
          transform: translateX(0);
        }
        .compact-tabs { display: flex; }
        .compact-close {
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
      }
    </style>
    <script>
      // Apply theme as early as possible to avoid a flash.
      (function () {
        try {
          const saved = String(localStorage.getItem("atlas-theme") || "").trim();
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          const theme = saved || (prefersLight ? "light" : "dark");
          document.documentElement.dataset.theme = theme;
        } catch (_) {
          document.documentElement.dataset.theme = "dark";
        }
      })();
    </script>
  </head>
  <body>
    <div id="app">
      <div id="side-panel">
        <button id="panel-toggle" type="button" title="Collapse panel">◀</button>
        <button id="compact-panel-close" class="compact-close" type="button" title="Close panel">✕</button>
        <div id="panel-resize-handle"></div>
        <div class="panel-tabs">
          <button id="tab-general-btn" class="tab-btn active" type="button">General</button>
          <button id="tab-layers-btn" class="tab-btn" type="button">Layers</button>
          <button id="tab-catalog-btn" class="tab-btn" type="button">Catalog</button>
          <button id="tab-settings-btn" class="tab-btn" type="button">Settings</button>
        </div>

        <div id="tab-general" class="tab-page">
          <div class="section">
            <h3>Mode</h3>
            <div class="tabs">
              <button id="mode-2d" class="tab-btn" type="button" disabled>2D</button>
              <button id="mode-3d" class="tab-btn active" type="button">3D</button>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Switches the active surface. Layers stay the same.
            </div>
          </div>

          <div class="section">
            <h3>Upload</h3>
            <label for="file-geojson">Upload GIS file (GeoJSON)</label>
            <input id="file-geojson" type="file" accept=".json,.geojson,application/geo+json,application/json" />
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Supports GeoJSON FeatureCollection/Feature/bare geometry with Point/LineString/Polygon (+ Multi*).
            </div>
            <div id="uploaded-info" style="margin-top:10px; font-size:12px; color:#cbd5e1; line-height:1.35;">
              <div style="color:var(--muted);">No upload loaded.</div>
            </div>
          </div>
          <div class="section">
            <h3>Overlays</h3>
            <label class="checkbox">
              <input id="toggle-graticule" type="checkbox" />
              <span>Show graticule</span>
            </label>
          </div>
          <div class="section">
            <h3>Status</h3>
            <div id="status-text" style="font-size:12px; color:#cbd5e1;">Ready</div>
            <div id="surface-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Surface: idle</div>
            <div id="dem-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Terrain (backend): unknown</div>
            <div id="terrain-client-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Terrain (client): idle</div>
            <div id="cursor-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Cursor: —</div>
            <div id="pick-text" style="font-size:12px; color:var(--muted); margin-top:2px;">Pick: —</div>
          </div>

          <div class="section">
            <h3>Surface</h3>
            <label class="checkbox">
              <input id="surface-use-pmtiles" type="checkbox" checked />
              <span>Use lightweight PMTiles base surface</span>
            </label>
            <label for="surface-pmtiles-max-zoom" style="margin-top:8px;">PMTiles refinement max zoom</label>
            <div class="row">
              <input id="surface-pmtiles-max-zoom" type="range" min="0" max="5" step="1" value="3" />
              <span id="surface-pmtiles-max-zoom-value" class="value">3</span>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Loads z0 immediately, then refines up to the max zoom. Higher zoom = more detail + more requests.
            </div>
          </div>
        </div>

        <div id="tab-layers" class="tab-page hidden">
          <div class="section">
            <h3>Points</h3>
            <label for="city-size">Point size (px)</label>
            <div class="row">
              <input id="city-size" type="range" min="1" max="24" step="1" value="4" />
              <span id="city-size-value" class="value">4</span>
            </div>
          </div>

          <div class="section">
            <h3>Lines</h3>
            <label for="line-width">Line width (px)</label>
            <div class="row">
              <input id="line-width" type="range" min="1" max="16" step="0.5" value="2.5" />
              <span id="line-width-value" class="value">2.5</span>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Note: this viewer uses simple per-layer styles (color/opacity/lift/width), not rule-based GIS symbology.
            </div>
          </div>

          <div class="section">
            <h3>Layers</h3>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-world-base" type="checkbox" checked />
                <span>World base (built-in)</span>
              </label>
              <input id="layer-world-base-color" type="color" value="#33a85a" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-world-base-opacity" type="range" min="0" max="1" step="0.01" value="0.85" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-world-base-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-terrain" type="checkbox" />
                <span>3D terrain mesh (streaming)</span>
              </label>
              <div class="muted" style="font-size:12px;">Loads on-demand tiles when enabled.</div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-cities" type="checkbox" />
                <span>Cities (built-in)</span>
              </label>
              <input id="layer-cities-color" type="color" value="#ff4040" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-cities-opacity" type="range" min="0" max="1" step="0.01" value="0.95" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-cities-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-corridors" type="checkbox" />
                <span>Air corridors (built-in)</span>
              </label>
              <input id="layer-corridors-color" type="color" value="#ffd640" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-corridors-opacity" type="range" min="0" max="1" step="0.01" value="0.90" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-corridors-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-regions" type="checkbox" />
                <span>Regions (built-in)</span>
              </label>
              <input id="layer-regions-color" type="color" value="#19e6bf" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-regions-opacity" type="range" min="0" max="1" step="0.01" value="0.30" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-regions-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-points" type="checkbox" />
                <span id="layer-uploaded-points-label">Uploaded points</span>
              </label>
              <input id="layer-uploaded-points-color" type="color" value="#99f2ff" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-points-opacity" type="range" min="0" max="1" step="0.01" value="0.95" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-points-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-corridors" type="checkbox" />
                <span id="layer-uploaded-corridors-label">Uploaded lines</span>
              </label>
              <input id="layer-uploaded-corridors-color" type="color" value="#d9f299" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-corridors-opacity" type="range" min="0" max="1" step="0.01" value="0.90" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-corridors-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-regions" type="checkbox" />
                <span id="layer-uploaded-regions-label">Uploaded polygons</span>
              </label>
              <input id="layer-uploaded-regions-color" type="color" value="#73b7ff" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-regions-opacity" type="range" min="0" max="1" step="0.01" value="0.25" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-regions-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:10px;">
              Tip: you can enable multiple layers at once. Click on a point layer to pick the nearest marker.
            </div>
          </div>
        </div>

        <div id="tab-catalog" class="tab-page hidden">
          <div class="section">
            <h3>Catalog</h3>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-bottom:10px;">
              Uploaded layers are stored locally (in AVC format) and listed here. Built-ins are listed as read-only.
            </div>
            <div id="catalog-list" style="display:flex; flex-direction:column; gap:10px;"></div>
            <div id="catalog-empty" class="muted" style="font-size:12px; line-height:1.35;">
              No catalog entries yet. Upload a GeoJSON file in the General tab.
            </div>
          </div>
        </div>

        <div id="tab-settings" class="tab-page hidden">
          <div class="section">
            <h3>Appearance</h3>
            <label for="theme-select">Theme</label>
            <select id="theme-select">
              <option value="dark">Dark</option>
              <option value="deep-dark">Deep Dark</option>
              <option value="light">Light</option>
            </select>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Affects UI and globe colors (base surface + ocean/space).
            </div>
          </div>
          <div class="section">
            <h3>Lighting</h3>
            <label class="checkbox">
              <input id="toggle-real-sun" type="checkbox" checked />
              <span>Real-time sun shadows</span>
            </label>
            <div class="muted" style="font-size:12px; line-height:1.35;">
              Syncs the globe lighting to your current system time.
            </div>
          </div>
          <div class="section">
            <h3>Globe rotation</h3>
            <label class="checkbox">
              <input id="toggle-auto-rotate" type="checkbox" checked />
              <span>Auto-rotate globe</span>
            </label>
            <label for="auto-rotate-speed" style="margin-top:8px;">Rotation speed (deg/s)</label>
            <div class="row">
              <input id="auto-rotate-speed" type="range" min="0" max="2" step="0.01" value="0.15" />
              <span id="auto-rotate-speed-value" class="value">0.15</span>
            </div>
          </div>
        </div>
      </div>
      <div id="map-area">
        <canvas id="atlas-canvas-2d" width="1280" height="720" class="hidden"></canvas>
        <canvas id="atlas-canvas-3d" width="1280" height="720"></canvas>
        <div id="compact-tabs" class="compact-tabs" aria-label="Panel shortcuts">
          <button class="btn" data-tab="general" type="button" title="General" aria-label="General">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 10.5L12 3l9 7.5" />
                <path d="M5 10v10h14V10" />
                <path d="M9 20v-6h6v6" />
              </svg>
            </span>
            <span class="sr-only">General</span>
          </button>
          <button class="btn" data-tab="layers" type="button" title="Layers" aria-label="Layers">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 3l9 5-9 5-9-5 9-5z" />
                <path d="M3 12l9 5 9-5" />
                <path d="M3 16.5l9 5 9-5" />
              </svg>
            </span>
            <span class="sr-only">Layers</span>
          </button>
          <button class="btn" data-tab="catalog" type="button" title="Catalog" aria-label="Catalog">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 19V6a2 2 0 0 1 2-2h12v17" />
                <path d="M6 4v16" />
                <path d="M18 21H6a2 2 0 0 1-2-2" />
              </svg>
            </span>
            <span class="sr-only">Catalog</span>
          </button>
          <button class="btn" data-tab="settings" type="button" title="Settings" aria-label="Settings">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z" />
                <path d="M19.4 15a7.8 7.8 0 0 0 .1-1 7.8 7.8 0 0 0-.1-1l2-1.6-2-3.4-2.4 1a8.4 8.4 0 0 0-1.7-1l-.4-2.6H9.1L8.7 7a8.4 8.4 0 0 0-1.7 1l-2.4-1-2 3.4L4.6 13a7.8 7.8 0 0 0-.1 1 7.8 7.8 0 0 0 .1 1l-2 1.6 2 3.4 2.4-1a8.4 8.4 0 0 0 1.7 1l.4 2.6h5.8l.4-2.6a8.4 8.4 0 0 0 1.7-1l2.4 1 2-3.4-2-1.6z" />
              </svg>
            </span>
            <span class="sr-only">Settings</span>
          </button>
        </div>
        <div id="map-controls" class="map-controls" data-pos="right" aria-label="Map controls">
          <button id="map-view" class="btn small" type="button" title="Toggle 2D/3D view">3D</button>
          <button id="map-compass" class="btn" type="button" title="North/South orientation">
            <span id="compass-needle" aria-hidden="true"></span>
            <span class="compass-label" aria-hidden="true">N</span>
          </button>
          <button id="map-home" class="btn" type="button" title="Reset camera (R)">⌂</button>
          <button id="map-zoom-in" class="btn" type="button" title="Zoom in">+</button>
          <button id="map-zoom-out" class="btn" type="button" title="Zoom out">−</button>
          <button id="map-mode" class="btn small" type="button" title="Lock drag mode">Auto</button>
          <button id="map-graticule" class="btn small" type="button" title="Toggle graticule">Grid</button>
          <button id="map-sun" class="btn small" type="button" title="Toggle real-time sun">Sun</button>
          <button id="map-help" class="btn small" type="button" title="Show controls">?</button>
          <div id="map-help-text" class="hint hidden">
            3D: LMB drag orbit • RMB/Shift pan<br />
            2D: drag pan<br />
            Wheel / Pinch: zoom • Click: pick<br />
            R: reset
          </div>
        </div>
      </div>
    </div>
    <script type="module">
      function normalizeTheme(theme) {
        const t = String(theme || "").trim().toLowerCase();
        if (t === "deep-dark" || t === "deep" || t === "black") return "deep-dark";
        if (t === "light" || t === "day") return "light";
        return "dark";
      }

      function getInitialTheme() {
        try {
          const saved = String(localStorage.getItem("atlas-theme") || "").trim();
          if (saved) return normalizeTheme(saved);
        } catch (_) {
          // ignore
        }
        const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
        return prefersLight ? "light" : "dark";
      }

      function applyTheme(theme, wasm) {
        const t = normalizeTheme(theme);
        document.documentElement.dataset.theme = t;
        try { localStorage.setItem("atlas-theme", t); } catch (_) {}
        try { wasm?.set_theme?.(t); } catch (err) { console.error("set_theme failed", err); }
        return t;
      }

      async function gunzipIfNeeded(bytes) {
        if (!bytes || bytes.length < 2) return bytes;
        if (bytes[0] !== 0x1f || bytes[1] !== 0x8b) return bytes;

        // Modern browsers: native gzip decompression.
        if (typeof DecompressionStream !== "undefined") {
          const ds = new DecompressionStream("gzip");
          const stream = new Blob([bytes]).stream().pipeThrough(ds);
          const ab = await new Response(stream).arrayBuffer();
          return new Uint8Array(ab);
        }

        // Fallback: dynamically load pako.
        const pako = await import("https://esm.sh/pako@2.1.0");
        return pako.ungzip(bytes);
      }

      async function tryLoadPmtilesBaseSurface(wasm) {
        // Feature flag (optional): set `window.ATLAS_USE_PMTILES_SURFACE = false` to disable.
        if (window.ATLAS_USE_PMTILES_SURFACE === false) return false;

        const url = "assets/world.pmtiles";
        try {
          // Load libs on demand.
          const pm = await import("https://esm.sh/pmtiles@3.2.0");
          const vt = await import("https://esm.sh/@mapbox/vector-tile@1.3.1");
          const PbfMod = await import("https://esm.sh/pbf@3.2.1");
          const Pbf = PbfMod.default;
          const { PMTiles, FetchSource } = pm;
          const { VectorTile } = vt;

          // Build a PMTiles reader that uses HTTP range requests.
          const p = new PMTiles(new FetchSource(url));

          // Confirm archive is readable.
          const header = await p.getHeader();
          const maxZoomAvailable = Number.isFinite(header?.maxZoom) ? header.maxZoom : 0;

          // Limit global refinement to avoid hammering the browser with requests.
          // You can override via `window.ATLAS_PMTILES_MAX_ZOOM`.
          const maxZoom = Math.max(0, Math.min(maxZoomAvailable, Number(window.ATLAS_PMTILES_MAX_ZOOM ?? 3)));
          const layerId = String(window.ATLAS_PMTILES_LAYER_ID || "ne_10m_land");

          if (!wasm?.begin_base_world_stream || !wasm?.append_base_world_geojson_chunk || !wasm?.finish_base_world_stream) {
            console.warn("PMTiles base surface: missing wasm streaming APIs; falling back to world.json");
            return false;
          }

          wasm.begin_base_world_stream();

          const maxFeaturesPerTile = Number(window.ATLAS_PMTILES_MAX_FEATURES_PER_TILE ?? 5000);
          const concurrency = Math.max(1, Math.min(8, Number(window.ATLAS_PMTILES_CONCURRENCY ?? 4)));

          async function loadTile(z, x, y) {
            const ab = await p.getZxy(z, x, y);
            if (!ab) return null;
            let bytes = new Uint8Array(ab);
            bytes = await gunzipIfNeeded(bytes);
            const tile = new VectorTile(new Pbf(bytes));
            const layer = tile.layers?.[layerId];
            if (!layer || !layer.length) return null;

            const features = [];
            const n = Math.min(layer.length, maxFeaturesPerTile);
            for (let i = 0; i < n; i++) {
              const f = layer.feature(i);
              // 3 = polygon in MVT
              if (f.type !== 3) continue;
              const gj = f.toGeoJSON(x, y, z);
              // Reduce payload: drop properties
              features.push({ type: "Feature", properties: {}, geometry: gj.geometry });
            }
            if (!features.length) return null;
            return { type: "FeatureCollection", features };
          }

          async function loadZoom(z) {
            const n = 1 << z;
            const tasks = [];
            let loadedTiles = 0;
            let pendingBatch = 0;

            const schedule = async (z, x, y) => {
              const fc = await loadTile(z, x, y);
              if (fc) {
                wasm.append_base_world_geojson_chunk(JSON.stringify(fc));
                pendingBatch++;
                // Periodically flush so the user sees progressive refinement.
                if (pendingBatch >= 4) {
                  pendingBatch = 0;
                  wasm.finish_base_world_stream();
                }
              }
              loadedTiles++;
            };

            // Simple concurrency-limited loop.
            for (let y = 0; y < n; y++) {
              for (let x = 0; x < n; x++) {
                tasks.push({ z, x, y });
              }
            }

            let idx = 0;
            async function worker() {
              while (idx < tasks.length) {
                const t = tasks[idx++];
                await schedule(t.z, t.x, t.y);
              }
            }
            await Promise.all(Array.from({ length: concurrency }, () => worker()));
            if (pendingBatch > 0) wasm.finish_base_world_stream();
            return loadedTiles;
          }

          // Always load z0 immediately so the globe has land right away.
          await loadZoom(0);
          wasm.finish_base_world_stream();

          // Progressive refinement.
          for (let z = 1; z <= maxZoom; z++) {
            await loadZoom(z);
            wasm.finish_base_world_stream();
          }

          console.log(`PMTiles base surface loaded (z0..z${maxZoom}, layer=${layerId})`);
          return true;
        } catch (err) {
          console.warn("PMTiles base surface load failed; falling back to world.json", err);
          try { wasm.finish_base_world_stream?.(); } catch (_) {}
          return false;
        }
      }

      function getPmtilesSurfacePrefs() {
        let enabled = true;
        let maxZoom = 3;
        try {
          const v = localStorage.getItem("atlas-surface-pmtiles-enabled");
          if (v === "false") enabled = false;
          if (v === "true") enabled = true;
        } catch (_) {}
        try {
          const z = Number(localStorage.getItem("atlas-surface-pmtiles-max-zoom"));
          if (Number.isFinite(z)) maxZoom = Math.max(0, Math.min(5, Math.floor(z)));
        } catch (_) {}
        return { enabled, maxZoom };
      }

      function setPmtilesSurfacePrefs(enabled, maxZoom) {
        try { localStorage.setItem("atlas-surface-pmtiles-enabled", enabled ? "true" : "false"); } catch (_) {}
        try { localStorage.setItem("atlas-surface-pmtiles-max-zoom", String(maxZoom)); } catch (_) {}
      }

      function applyPmtilesSurfacePrefsToGlobals(prefs) {
        window.ATLAS_USE_PMTILES_SURFACE = !!prefs.enabled;
        window.ATLAS_PMTILES_MAX_ZOOM = prefs.maxZoom;
      }

      async function reloadBaseSurface(wasm) {
        // Prefer backend surface tiles if available (existing behavior), otherwise base-world fallback.
        // Here we only decide the fallback base-world source.
        const prefs = getPmtilesSurfacePrefs();
        applyPmtilesSurfacePrefsToGlobals(prefs);
        if (prefs.enabled) {
          const ok = await tryLoadPmtilesBaseSurface(wasm);
          if (ok) return;
        }
        try { wasm.load_base_world?.(); } catch (err) { console.error("load_base_world failed", err); }
      }

      function wireSurfacePrefs(wasm) {
        const cb = document.getElementById("surface-use-pmtiles");
        const slider = document.getElementById("surface-pmtiles-max-zoom");
        const value = document.getElementById("surface-pmtiles-max-zoom-value");
        if (!cb || !slider || !value) return;

        const prefs = getPmtilesSurfacePrefs();
        cb.checked = !!prefs.enabled;
        slider.value = String(prefs.maxZoom);
        value.textContent = String(prefs.maxZoom);

        const apply = async () => {
          const enabled = !!cb.checked;
          const maxZoom = Math.max(0, Math.min(5, Math.floor(Number(slider.value) || 0)));
          slider.value = String(maxZoom);
          value.textContent = String(maxZoom);
          setPmtilesSurfacePrefs(enabled, maxZoom);
          await reloadBaseSurface(wasm);
        };

        cb.addEventListener("change", () => {
          apply().catch((e) => console.warn("surface apply failed", e));
        });
        slider.addEventListener("input", () => {
          const maxZoom = Math.max(0, Math.min(5, Math.floor(Number(slider.value) || 0)));
          value.textContent = String(maxZoom);
        });
        slider.addEventListener("change", () => {
          apply().catch((e) => console.warn("surface apply failed", e));
        });
      }

      function main(wasm) {
        // Apply theme early so both UI and renderer pick consistent defaults.
        const theme = applyTheme(getInitialTheme(), wasm);
        wireUi(wasm);
        wireSurfacePrefs(wasm);
        resizeCanvas(wasm);
        window.addEventListener("resize", () => {
          resizeCanvas(wasm);
          if (isCompactLayout()) {
            document.getElementById("side-panel")?.classList.remove("compact-open");
          }
        });
        wasm.init_canvas_2d();
        wasm.init_wgpu();
        // Apply persisted surface prefs and load base surface.
        const prefs = getPmtilesSurfacePrefs();
        applyPmtilesSurfacePrefsToGlobals(prefs);
        reloadBaseSurface(wasm);
        detectBackendAvailability(wasm);
        startSurfaceStatusPolling(wasm);
        startTerrainClientStatusPolling(wasm);
        startAnimation(wasm);
      }

      function getTerrainPreference() {
        try {
          const v = String(localStorage.getItem("atlas-terrain-enabled") || "").trim().toLowerCase();
          if (v === "true") return true;
          if (v === "false") return false;
        } catch (_) {
          // ignore
        }
        return null;
      }

      function setTerrainPreference(enabled) {
        try {
          localStorage.setItem("atlas-terrain-enabled", enabled ? "true" : "false");
        } catch (_) {
          // ignore
        }
      }

      async function detectBackendAvailability(wasm) {
        const override = window.ATLAS_BACKEND_URL || "";
        const host = window.location.hostname || "localhost";
        const scheme = window.location.protocol === "https:" ? "https" : "http";
        const fallbackDocker = `${scheme}://${host}:9102`;
        const fallbackLocal = `${scheme}://${host}:9100`;
        const candidates = [
          String(override || "").trim(),
          fallbackDocker,
          fallbackLocal,
        ].filter(Boolean);

        for (const base of candidates) {
          try {
            const resp = await fetch(`${base}/healthz`, { method: "GET" });
            if (resp.ok) {
              window.__atlasBackendUrl = base;
              window.__atlasStacUrl = `${base}/stac`;
              setStatus(`Backend: connected (${base})`);
              startTerrainStatusPolling(base);

              // If a backend is available, enable streaming terrain by default.
              // Persist the choice so users can opt out.
              const pref = getTerrainPreference();
              const shouldEnableTerrain = pref === null ? true : !!pref;
              if (pref === null) setTerrainPreference(true);

              if (shouldEnableTerrain) {
                try { wasm?.set_layer_visible?.("terrain", true); } catch (err) { console.error("enable terrain failed", err); }
                const cb = document.getElementById("layer-terrain");
                if (cb) cb.checked = true;
              }
              return;
            }
          } catch (err) {
            // ignore and try next
          }
        }

        window.__atlasBackendUrl = "";
        window.__atlasStacUrl = "https://copernicus-dem-30m-stac.s3.amazonaws.com";
        setStatus("Backend: offline (using defaults)");
        setDemStatus("Terrain (backend): offline");
      }

      function startAnimation(wasm) {
        function loop() {
          try {
            wasm.advance_frame();
            if (window.__atlasUpdateCompass) window.__atlasUpdateCompass();
          } catch (e) {
            console.error("advance_frame failed", e);
            return;
          }
          window.requestAnimationFrame(loop);
        }
        window.requestAnimationFrame(loop);
      }

      function isCompactLayout() {
        return window.matchMedia("(max-width: 900px)").matches;
      }

      function resizeCanvas(wasm) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const canvas2d = document.getElementById("atlas-canvas-2d");
        const canvas3d = document.getElementById("atlas-canvas-3d");
        canvas2d.width = width;
        canvas2d.height = height;
        canvas3d.width = width;
        canvas3d.height = height;
        wasm.set_canvas_sizes(width, height);
      }

      function setStatus(text) {
        document.getElementById("status-text").textContent = text;
      }

      function setDemStatus(text) {
        document.getElementById("dem-status-text").textContent = text;
      }

      function setSurfaceStatus(text) {
        document.getElementById("surface-status-text").textContent = text;
      }

      function setTerrainClientStatus(text) {
        document.getElementById("terrain-client-status-text").textContent = text;
      }

      function startTerrainStatusPolling(baseUrl) {
        async function poll() {
          if (!baseUrl) {
            setDemStatus("Terrain (backend): offline");
            return;
          }
          try {
            const resp = await fetch(`${baseUrl}/terrain/status`, { method: "GET" });
            if (!resp.ok) {
              setDemStatus(`Terrain (backend): status unavailable (${resp.status})`);
              return;
            }
            const data = await resp.json();
            const tiles = Number.isFinite(data.tiles_count) ? data.tiles_count : 0;
            const suffix = data.tiles_count_truncated ? "+" : "";
            const datum = data.vertical_datum ? ` • ${String(data.vertical_datum)}` : "";
            if (data.status === "ready") {
              setDemStatus(`Terrain (backend): ready (${tiles}${suffix} cached${datum})`);
            } else if (data.status === "empty") {
              setDemStatus(`Terrain (backend): empty cache${datum}`);
            } else {
              setDemStatus(`Terrain (backend): ${String(data.status || "unknown")}${datum}`);
            }
          } catch (err) {
            setDemStatus("Terrain (backend): status error");
          }
        }

        poll();
        window.setInterval(poll, 10_000);
      }

      function startTerrainClientStatusPolling(wasm) {
        function poll() {
          try {
            if (!wasm.get_terrain_client_status) {
              setTerrainClientStatus("Terrain (client): unavailable");
              return;
            }
            const status = wasm.get_terrain_client_status();
            const enabled = !!status.enabled;
            const loading = !!status.loading;
            const zoom = status.zoom !== undefined ? ` z${status.zoom}` : "";
            const source = status.source ? ` @ ${status.source}` : "";
            const datum = status.vertical_datum ? ` • ${String(status.vertical_datum)}` : "";
            if (!enabled) {
              setTerrainClientStatus("Terrain (client): disabled");
              return;
            }
            if (loading) {
              setTerrainClientStatus(`Terrain (client): loading${zoom}${source}${datum}`);
              return;
            }
            if (status.last_error) {
              setTerrainClientStatus(`Terrain (client): error (${status.last_error})`);
              return;
            }
            if (status.tileset_loaded) {
              setTerrainClientStatus(`Terrain (client): ready${zoom}${source}${datum}`);
              return;
            }
            setTerrainClientStatus("Terrain (client): idle");
          } catch (err) {
            setTerrainClientStatus("Terrain (client): status error");
          }
        }

        poll();
        window.setInterval(poll, 3_000);
      }

      function startSurfaceStatusPolling(wasm) {
        function poll() {
          try {
            if (!wasm.get_surface_status) {
              setSurfaceStatus("Surface: unavailable");
              return;
            }
            const status = wasm.get_surface_status();
            const zoom = status.zoom !== undefined ? ` z${status.zoom}` : "";
            const source = status.source ? ` @ ${status.source}` : "";
            if (status.loading) {
              setSurfaceStatus(`Surface: loading${zoom}${source}`);
              return;
            }
            if (status.error) {
              setSurfaceStatus(`Surface: error (${status.error})`);
              return;
            }
            if (status.tileset_loaded) {
              setSurfaceStatus(`Surface: tiles ready${zoom}${source}`);
              return;
            }
            if (status.loaded) {
              setSurfaceStatus(`Surface: ready${source}`);
              return;
            }
            setSurfaceStatus("Surface: idle");
          } catch (err) {
            setSurfaceStatus("Surface: status error");
          }
        }

        poll();
        window.setInterval(poll, 2_000);
      }

      function wireUi(wasm) {
        const sidePanel = document.getElementById("side-panel");
        const compactTabs = document.getElementById("compact-tabs");
        const compactClose = document.getElementById("compact-panel-close");

        const tabGeneralBtn = document.getElementById("tab-general-btn");
        const tabLayersBtn = document.getElementById("tab-layers-btn");
        const tabCatalogBtn = document.getElementById("tab-catalog-btn");
        const tabSettingsBtn = document.getElementById("tab-settings-btn");
        const tabGeneral = document.getElementById("tab-general");
        const tabLayers = document.getElementById("tab-layers");
        const tabCatalog = document.getElementById("tab-catalog");
        const tabSettings = document.getElementById("tab-settings");

        const catalogList = document.getElementById("catalog-list");
        const catalogEmpty = document.getElementById("catalog-empty");

        const fileGeoJson = document.getElementById("file-geojson");
        const uploadedInfo = document.getElementById("uploaded-info");
        const toggleGraticule = document.getElementById("toggle-graticule");
        const toggleRealSun = document.getElementById("toggle-real-sun");
        const toggleAutoRotate = document.getElementById("toggle-auto-rotate");
        const autoRotateSpeed = document.getElementById("auto-rotate-speed");
        const autoRotateSpeedValue = document.getElementById("auto-rotate-speed-value");
        const themeSelect = document.getElementById("theme-select");
        const citySize = document.getElementById("city-size");
        const citySizeValue = document.getElementById("city-size-value");
        const lineWidth = document.getElementById("line-width");
        const lineWidthValue = document.getElementById("line-width-value");
        const canvas2d = document.getElementById("atlas-canvas-2d");
        const canvas3d = document.getElementById("atlas-canvas-3d");

        if (themeSelect) {
          themeSelect.value = normalizeTheme(document.documentElement.dataset.theme || "dark");
          themeSelect.addEventListener("change", (e) => {
            applyTheme(e.target.value, wasm);
          });
        }

        const mode2dBtn = document.getElementById("mode-2d");
        const mode3dBtn = document.getElementById("mode-3d");

        const mapHome = document.getElementById("map-home");
        const mapZoomIn = document.getElementById("map-zoom-in");
        const mapZoomOut = document.getElementById("map-zoom-out");
        const mapView = document.getElementById("map-view");
        const mapCompass = document.getElementById("map-compass");
        const compassNeedle = document.getElementById("compass-needle");
        const mapMode = document.getElementById("map-mode");
        const mapGraticule = document.getElementById("map-graticule");
        const mapSun = document.getElementById("map-sun");
        const mapHelp = document.getElementById("map-help");
        const mapHelpText = document.getElementById("map-help-text");

        const cursorText = document.getElementById("cursor-text");
        const pickText = document.getElementById("pick-text");

        const layerWorldBase = document.getElementById("layer-world-base");
        const layerWorldBaseColor = document.getElementById("layer-world-base-color");
        const layerWorldBaseOpacity = document.getElementById("layer-world-base-opacity");
        const layerWorldBaseLift = document.getElementById("layer-world-base-lift");

        const layerTerrain = document.getElementById("layer-terrain");

        const layerCities = document.getElementById("layer-cities");
        const layerCitiesColor = document.getElementById("layer-cities-color");
        const layerCitiesOpacity = document.getElementById("layer-cities-opacity");
        const layerCitiesLift = document.getElementById("layer-cities-lift");

        const layerCorridors = document.getElementById("layer-corridors");
        const layerCorridorsColor = document.getElementById("layer-corridors-color");
        const layerCorridorsOpacity = document.getElementById("layer-corridors-opacity");
        const layerCorridorsLift = document.getElementById("layer-corridors-lift");

        const layerRegions = document.getElementById("layer-regions");
        const layerRegionsColor = document.getElementById("layer-regions-color");
        const layerRegionsOpacity = document.getElementById("layer-regions-opacity");
        const layerRegionsLift = document.getElementById("layer-regions-lift");

        const layerUploadedPoints = document.getElementById("layer-uploaded-points");
        const layerUploadedPointsLabel = document.getElementById("layer-uploaded-points-label");
        const layerUploadedPointsColor = document.getElementById("layer-uploaded-points-color");
        const layerUploadedPointsOpacity = document.getElementById("layer-uploaded-points-opacity");
        const layerUploadedPointsLift = document.getElementById("layer-uploaded-points-lift");

        const layerUploadedCorridors = document.getElementById("layer-uploaded-corridors");
        const layerUploadedCorridorsLabel = document.getElementById("layer-uploaded-corridors-label");
        const layerUploadedCorridorsColor = document.getElementById("layer-uploaded-corridors-color");
        const layerUploadedCorridorsOpacity = document.getElementById("layer-uploaded-corridors-opacity");
        const layerUploadedCorridorsLift = document.getElementById("layer-uploaded-corridors-lift");

        const layerUploadedRegions = document.getElementById("layer-uploaded-regions");
        const layerUploadedRegionsLabel = document.getElementById("layer-uploaded-regions-label");
        const layerUploadedRegionsColor = document.getElementById("layer-uploaded-regions-color");
        const layerUploadedRegionsOpacity = document.getElementById("layer-uploaded-regions-opacity");
        const layerUploadedRegionsLift = document.getElementById("layer-uploaded-regions-lift");

        function formatGeometrySummary(points, lines, polygons) {
          const p = Number(points ?? 0);
          const l = Number(lines ?? 0);
          const g = Number(polygons ?? 0);
          const parts = [];
          if (p > 0) parts.push(`Points: ${p}`);
          if (l > 0) parts.push(`Lines: ${l}`);
          if (g > 0) parts.push(`Polygons: ${g}`);
          if (parts.length === 0) return "Empty";
          return parts.join(" • ");
        }

        function setUploadedInfo({ name, points, lines, polygons, catalog_persisted, catalog_error, skipped_coords, fixed_swapped, fixed_web_mercator, error }) {
          if (error) {
            uploadedInfo.innerHTML = `<div style="color:var(--danger);">Upload error: ${String(error)}</div>`;
            return;
          }
          if (!name) {
            uploadedInfo.innerHTML = `<div style="color:var(--muted);">No upload loaded.</div>`;
            return;
          }

          const skipped = Number(skipped_coords ?? 0);
          const swapped = Number(fixed_swapped ?? 0);
          const merc = Number(fixed_web_mercator ?? 0);
          const hasDiag = (skipped + swapped + merc) > 0;
          const persisted = catalog_persisted === undefined ? null : !!catalog_persisted;
          const catErr = String(catalog_error ?? "").trim();

          const geomSummary = formatGeometrySummary(points, lines, polygons);
          uploadedInfo.innerHTML = `
            <div><span style="color:var(--info);">Uploaded:</span> ${name}</div>
            <div style="color:var(--muted);">${geomSummary}</div>
            ${persisted === null ? "" : (persisted ? `<div style="color:var(--success); font-size:12px;">Saved to Catalog.</div>` : `<div style="color:var(--warning); font-size:12px;">Not saved to Catalog.</div>${catErr ? `<div style=\"color:var(--muted); font-size:12px;\">${catErr}</div>` : ``}`) }
            ${hasDiag ? `<div style="color:var(--muted);">Coords: fixed swap ${swapped} • fixed mercator ${merc} • skipped ${skipped}</div>` : ""}
          `;
        }

        function wireLayerControls() {
          function bind(id, checkbox, color, opacity, lift) {
            if (checkbox) {
              checkbox.addEventListener("change", (e) => {
                try { wasm.set_layer_visible(id, !!e.target.checked); } catch (err) { console.error(err); }
              });
            }
            if (color) {
              color.addEventListener("input", (e) => {
                try { wasm.set_layer_color_hex(id, e.target.value); } catch (err) { console.error(err); }
              });
            }
            if (opacity) {
              opacity.addEventListener("input", (e) => {
                try { wasm.set_layer_opacity(id, Number(e.target.value)); } catch (err) { console.error(err); }
              });
            }
            if (lift) {
              lift.addEventListener("input", (e) => {
                try { wasm.set_layer_lift(id, Number(e.target.value)); } catch (err) { console.error(err); }
              });
            }
          }
          bind("world_base", layerWorldBase, layerWorldBaseColor, layerWorldBaseOpacity, layerWorldBaseLift);
          bind("terrain", layerTerrain, null, null, null);
          bind("cities", layerCities, layerCitiesColor, layerCitiesOpacity, layerCitiesLift);
          bind("air_corridors", layerCorridors, layerCorridorsColor, layerCorridorsOpacity, layerCorridorsLift);
          bind("regions", layerRegions, layerRegionsColor, layerRegionsOpacity, layerRegionsLift);
          bind("uploaded_points", layerUploadedPoints, layerUploadedPointsColor, layerUploadedPointsOpacity, layerUploadedPointsLift);
          bind("uploaded_corridors", layerUploadedCorridors, layerUploadedCorridorsColor, layerUploadedCorridorsOpacity, layerUploadedCorridorsLift);
          bind("uploaded_regions", layerUploadedRegions, layerUploadedRegionsColor, layerUploadedRegionsOpacity, layerUploadedRegionsLift);
        }

        wireLayerControls();

        // Persist terrain preference (on/off) across reloads.
        if (layerTerrain) {
          layerTerrain.addEventListener("change", (e) => {
            setTerrainPreference(!!e.target.checked);
          });
        }
        syncSymbologyControls();

        function syncSymbologyControls() {
          function syncLayer(id, checkbox, color, opacity, lift) {
            if (!wasm.get_layer_style) return;
            try {
              const style = wasm.get_layer_style(id);
              if (!style) return;
              if (checkbox) checkbox.checked = !!style.visible;
              if (color && style.color_hex) color.value = style.color_hex;
              if (opacity && style.opacity !== undefined) opacity.value = String(style.opacity);
              if (lift && style.lift !== undefined) lift.value = String(style.lift);
            } catch (err) {
              console.error("get_layer_style failed", err);
            }
          }

          syncLayer("world_base", layerWorldBase, layerWorldBaseColor, layerWorldBaseOpacity, layerWorldBaseLift);
          syncLayer("terrain", layerTerrain, null, null, null);
          syncLayer("cities", layerCities, layerCitiesColor, layerCitiesOpacity, layerCitiesLift);
          syncLayer("air_corridors", layerCorridors, layerCorridorsColor, layerCorridorsOpacity, layerCorridorsLift);
          syncLayer("regions", layerRegions, layerRegionsColor, layerRegionsOpacity, layerRegionsLift);
          syncLayer("uploaded_points", layerUploadedPoints, layerUploadedPointsColor, layerUploadedPointsOpacity, layerUploadedPointsLift);
          syncLayer("uploaded_corridors", layerUploadedCorridors, layerUploadedCorridorsColor, layerUploadedCorridorsOpacity, layerUploadedCorridorsLift);
          syncLayer("uploaded_regions", layerUploadedRegions, layerUploadedRegionsColor, layerUploadedRegionsOpacity, layerUploadedRegionsLift);

          if (wasm.get_city_marker_size) {
            try {
              const size = wasm.get_city_marker_size();
              citySize.value = String(size);
              citySizeValue.textContent = String(size);
            } catch (err) { console.error("get_city_marker_size failed", err); }
          }
          if (wasm.get_line_width_px) {
            try {
              const width = wasm.get_line_width_px();
              lineWidth.value = String(width);
              lineWidthValue.textContent = String(width);
            } catch (err) { console.error("get_line_width_px failed", err); }
          }
        }

        function setTab(which) {
          const isGeneral = which === "general";
          const isLayers = which === "layers";
          const isCatalog = which === "catalog";
          const isSettings = which === "settings";

          tabGeneralBtn.classList.toggle("active", isGeneral);
          tabLayersBtn.classList.toggle("active", isLayers);
          tabCatalogBtn.classList.toggle("active", isCatalog);
          tabSettingsBtn.classList.toggle("active", isSettings);

          tabGeneral.classList.toggle("hidden", !isGeneral);
          tabLayers.classList.toggle("hidden", !isLayers);
          tabCatalog.classList.toggle("hidden", !isCatalog);
          tabSettings.classList.toggle("hidden", !isSettings);

          if (isCatalog) {
            renderCatalog();
          }
          if (sidePanel && isCompactLayout()) {
            sidePanel.classList.add("compact-open");
          }
        }

        tabGeneralBtn.addEventListener("click", () => setTab("general"));
        tabLayersBtn.addEventListener("click", () => setTab("layers"));
        tabCatalogBtn.addEventListener("click", () => setTab("catalog"));
        tabSettingsBtn.addEventListener("click", () => setTab("settings"));

        if (compactTabs) {
          compactTabs.querySelectorAll("button[data-tab]").forEach((btn) => {
            btn.addEventListener("click", () => {
              const tab = btn.getAttribute("data-tab");
              if (tab) setTab(tab);
            });
          });
        }
        if (compactClose && sidePanel) {
          compactClose.addEventListener("click", () => {
            sidePanel.classList.remove("compact-open");
          });
        }

        // Start closed on compact layouts; opened by the right-side tab buttons.
        if (sidePanel && isCompactLayout()) {
          sidePanel.classList.remove("compact-open");
        }

        function applyUploadedSummary(summary, labelName) {
          const displayName = labelName || summary?.name || "uploaded";

          setUploadedInfo({
            name: displayName,
            points: summary?.points ?? 0,
            lines: summary?.lines ?? 0,
            polygons: summary?.polygons ?? 0,
          });

          layerUploadedPointsLabel.textContent = `Uploaded points (${displayName})`;
          layerUploadedCorridorsLabel.textContent = `Uploaded lines (${displayName})`;
          layerUploadedRegionsLabel.textContent = `Uploaded polygons (${displayName})`;
          const hasPoints = (summary?.points ?? 0) > 0;
          const hasLines = (summary?.lines ?? 0) > 0;
          const hasPolys = (summary?.polygons ?? 0) > 0;

          layerUploadedPoints.checked = hasPoints;
          layerUploadedCorridors.checked = hasLines;
          layerUploadedRegions.checked = hasPolys;

          try { wasm.set_layer_visible("uploaded_points", hasPoints); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_corridors", hasLines); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_regions", hasPolys); } catch (err) { /* ignore */ }
        }

        function clearUploadedUi() {
          setUploadedInfo({ name: "", points: 0, lines: 0, polygons: 0 });
          layerUploadedPointsLabel.textContent = "Uploaded points";
          layerUploadedCorridorsLabel.textContent = "Uploaded lines";
          layerUploadedRegionsLabel.textContent = "Uploaded polygons";
          layerUploadedPoints.checked = false;
          layerUploadedCorridors.checked = false;
          layerUploadedRegions.checked = false;
          try { wasm.set_layer_visible("uploaded_points", false); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_corridors", false); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_regions", false); } catch (err) { /* ignore */ }
        }

        async function renderCatalog() {
          if (!catalogList || !catalogEmpty) return;

          let entries = [];
          let builtins = [];
          try {
            entries = wasm.catalog_list?.() ?? [];
          } catch (err) {
            console.error("catalog_list failed", err);
            entries = [];
          }

          try {
            builtins = wasm.get_builtin_layers?.() ?? [];
          } catch (err) {
            builtins = [];
          }

          let currentCatalogId = "";
          try {
            const s = wasm.get_uploaded_summary?.();
            currentCatalogId = String(s?.catalog_id ?? "");
          } catch (err) {
            currentCatalogId = "";
          }

          catalogList.innerHTML = "";
          if (!Array.isArray(entries)) entries = [];
          if (!Array.isArray(builtins)) builtins = [];
          const allEntries = [...builtins, ...entries];
          const hasAny = allEntries.length > 0;
          catalogEmpty.style.display = hasAny ? "none" : "block";
          if (!hasAny) return;

          for (const e of allEntries) {
            const id = String(e?.id ?? "");
            const name = String(e?.name ?? id);
            const pts = Number(e?.points ?? 0);
            const lines = Number(e?.lines ?? 0);
            const polys = Number(e?.polygons ?? 0);
            const isBuiltin = !!e?.builtin;
            let loaded = false;
            if (isBuiltin) {
              try {
                const style = wasm.get_layer_style?.(id);
                loaded = !!style?.visible;
              } catch (err) {
                loaded = false;
              }
            } else {
              loaded = id && currentCatalogId && id === currentCatalogId;
            }
            const geomSummary = formatGeometrySummary(pts, lines, polys);

            const row = document.createElement("div");
            row.className = "section";
            row.style.padding = "10px";
            row.innerHTML = `
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:700;">${name}</div>
                ${loaded ? '<div style="font-size:11px; color:#86efac; font-weight:700;">Loaded</div>' : ''}
              </div>
              <div style="font-size:12px; color:var(--muted); margin-top:6px;">${geomSummary}</div>
              <div style="display:flex; gap:8px; margin-top:10px;">
                <button type="button" data-action="toggle">${loaded ? "Remove from scene" : "Add to scene"}</button>
                ${isBuiltin ? '' : '<button type="button" data-action="delete" style="border-color:#7f1d1d;">Delete</button>'}
              </div>
            `;

            const btnToggle = row.querySelector('button[data-action="toggle"]');
            const btnDelete = row.querySelector('button[data-action="delete"]');

            btnToggle?.addEventListener("click", async () => {
              try {
                if (isBuiltin) {
                  const nextVisible = !loaded;
                  wasm.set_layer_visible?.(id, nextVisible);
                  syncSymbologyControls();
                  renderCatalog();
                } else {
                  if (loaded) {
                    wasm.clear_uploaded?.();
                    clearUploadedUi();
                  } else {
                    const summary = await wasm.catalog_load(id);
                    applyUploadedSummary(summary, name);
                  }
                  renderCatalog();
                }
              } catch (err) {
                console.error("catalog toggle failed", err);
                setStatus("Catalog load failed (see console)");
              }
            });

            btnDelete?.addEventListener("click", async () => {
              try {
                if (loaded) {
                  wasm.clear_uploaded?.();
                  clearUploadedUi();
                }
                await wasm.catalog_delete(id);
                renderCatalog();
              } catch (err) {
                console.error("catalog delete failed", err);
                setStatus("Catalog delete failed (see console)");
              }
            });

            catalogList.appendChild(row);
          }
        }

        // Initial render.
        renderCatalog();

        let viewMode = "3d"; // 3d only (2d disabled)

        function applyViewMode(next) {
          viewMode = "3d";
          canvas2d.classList.toggle("hidden", viewMode !== "2d");
          canvas3d.classList.toggle("hidden", viewMode !== "3d");
          mode2dBtn?.classList.toggle("active", viewMode === "2d");
          mode3dBtn?.classList.toggle("active", viewMode === "3d");
          if (mapView) mapView.textContent = viewMode.toUpperCase();
          try { wasm.set_view_mode(viewMode); } catch (err) { console.error("set_view_mode failed", err); }
          updateCompass();
        }

        mode2dBtn?.addEventListener("click", () => applyViewMode("3d"));
        mode3dBtn?.addEventListener("click", () => applyViewMode("3d"));
        mapView?.addEventListener("click", () => applyViewMode("3d"));

        function activeCanvas() {
          return viewMode === "2d" ? canvas2d : canvas3d;
        }

        for (const c of [canvas2d, canvas3d]) {
          c.addEventListener("contextmenu", (e) => e.preventDefault());
        }

        function updateCompass() {
          if (!compassNeedle) return;
          let yawDeg = 0;
          if (viewMode === "3d") {
            try {
              yawDeg = Number(wasm.get_camera_yaw_deg?.() ?? 0);
            } catch (err) {
              yawDeg = 0;
            }
          }
          // Rotate needle opposite to yaw so it represents North on screen.
          const rot = -yawDeg;
          compassNeedle.style.transform = `translate(-50%, -100%) rotate(${rot}deg)`;
        }

        // Expose to the animation loop.
        window.__atlasUpdateCompass = updateCompass;

        mapCompass?.addEventListener("click", () => {
          // Reset yaw to a north-up orientation without resetting distance/pitch.
          try {
            wasm.set_camera_yaw_deg(0);
          } catch (err) {
            // ignore
          }
          updateCompass();
        });

        let dragging = false;
        let dragMode = "orbit"; // orbit | pan
        let lockMode = "auto"; // auto | orbit | pan
        let lastX = 0;
        let lastY = 0;
        let downX = 0;
        let downY = 0;
        let downButton = 0;
        let pendingDx = 0;
        let pendingDy = 0;
        let dragRaf = 0;

        // Touch pinch-zoom support (pointer events).
        const activePointers = new Map(); // pointerId -> { x, y, type }
        let pinching = false;
        let pinchLastDist = 0;

        function getTouchPair() {
          const pts = [];
          for (const [id, p] of activePointers) {
            if (p && p.type === "touch") pts.push({ id, x: p.x, y: p.y });
          }
          return pts.slice(0, 2);
        }

        function dist2(a, b) {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          return dx * dx + dy * dy;
        }

        function onPointerDown(e) {
          const canvas = activeCanvas();
          canvas.setPointerCapture(e.pointerId);

          if (e.pointerType === "touch") {
            // Track touch pointers for pinch.
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: "touch" });
            const pts = getTouchPair();
            if (pts.length === 2) {
              pinching = true;
              dragging = false;
              pinchLastDist = Math.sqrt(dist2(pts[0], pts[1]));
              return;
            }
          }

          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          downX = e.clientX;
          downY = e.clientY;
          downButton = e.button;

          // If a mode is locked, use it; otherwise: left=orbit, right/shift=pan.
          if (lockMode === "pan") {
            dragMode = "pan";
          } else if (lockMode === "orbit") {
            dragMode = "orbit";
          } else if (e.button === 2 || e.shiftKey) {
            dragMode = "pan";
          } else {
            dragMode = "orbit";
          }
        }

        function onPointerMove(e) {
          if (e.pointerType === "touch") {
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: "touch" });
            const pts = getTouchPair();
            if (pinching && pts.length === 2) {
              // Convert pinch distance changes into wheel-like deltas.
              const dist = Math.sqrt(dist2(pts[0], pts[1]));
              const delta = pinchLastDist - dist;
              pinchLastDist = dist;
              // Scale to feel reasonable; negative delta => pinch out => zoom in.
              const wheelLike = delta * 2.0;
              try {
                wasm.camera_zoom(wheelLike);
                updateCompass();
              } catch (err) {
                console.error("pinch zoom failed", err);
              }
              return;
            }
          }

          if (!dragging) {
            try {
              const info = wasm.cursor_move(e.offsetX, e.offsetY);
              if (info && info.hit) {
                cursorText.textContent = `Cursor: lon ${info.lon.toFixed(4)}°, lat ${info.lat.toFixed(4)}°`;
              } else {
                cursorText.textContent = "Cursor: —";
              }
            } catch (err) {
              // ignore
            }
          }
          if (!dragging) return;
          const dx = e.clientX - lastX;
          const dy = e.clientY - lastY;
          lastX = e.clientX;
          lastY = e.clientY;

          pendingDx += dx;
          pendingDy += dy;

          if (!dragRaf) {
            dragRaf = window.requestAnimationFrame(() => {
              dragRaf = 0;
              const px = pendingDx;
              const py = pendingDy;
              pendingDx = 0;
              pendingDy = 0;
              try {
                if (dragMode === "pan") {
                  wasm.camera_pan(px, py);
                } else {
                  wasm.camera_orbit(px, py);
                }
                updateCompass();
              } catch (err) {
                console.error("camera input failed", err);
              }
            });
          }
        }

        function stopDrag() {
          dragging = false;
          pinching = false;
          activePointers.clear();
        }
        function onPointerUp(e) {
          if (e.pointerType === "touch") {
            activePointers.delete(e.pointerId);
            const pts = getTouchPair();
            if (pts.length < 2) {
              pinching = false;
            }
            // Don't treat touch as click-to-pick.
            stopDrag();
            return;
          }

          // If it was a click (not a drag), run picking.
          const dx = e.clientX - downX;
          const dy = e.clientY - downY;
          const dist2 = dx * dx + dy * dy;
          if (downButton === 0 && dist2 < 16) {
            try {
              const picked = wasm.cursor_click(e.offsetX, e.offsetY);
              if (picked && picked.picked) {
                const kind = picked.kind ? String(picked.kind) : "feature";
                pickText.textContent = `Pick (${kind}): lon ${picked.lon.toFixed(4)}°, lat ${picked.lat.toFixed(4)}°`;
              } else {
                pickText.textContent = "Pick: —";
              }
            } catch (err) {
              console.error("pick failed", err);
            }
          }
          stopDrag();
        }

        function onWheel(e) {
          e.preventDefault();
          try {
            wasm.camera_zoom(e.deltaY);
            updateCompass();
          } catch (err) {
            console.error("camera_zoom failed", err);
          }
        }

        for (const c of [canvas2d, canvas3d]) {
          c.addEventListener("pointerdown", onPointerDown);
          c.addEventListener("pointermove", onPointerMove);
          c.addEventListener("pointerup", onPointerUp);
          c.addEventListener("pointercancel", stopDrag);
          c.addEventListener("pointerleave", stopDrag);
          c.addEventListener("wheel", onWheel, { passive: false });
        }

        window.addEventListener("keydown", (e) => {
          if (e.key === "r" || e.key === "R") {
            try {
              wasm.camera_reset();
              updateCompass();
            } catch (err) {
              console.error("camera_reset failed", err);
            }
          }
        });

        function syncMapToggles() {
          mapGraticule?.classList.toggle("active", !!toggleGraticule.checked);
          mapSun?.classList.toggle("active", !!toggleRealSun.checked);
          if (lockMode === "auto") mapMode.textContent = "Auto";
          if (lockMode === "orbit") mapMode.textContent = "Orbit";
          if (lockMode === "pan") mapMode.textContent = "Pan";
        }

        mapHome?.addEventListener("click", () => {
          try { wasm.camera_reset(); updateCompass(); } catch (err) { console.error("camera_reset failed", err); }
        });
        mapZoomIn?.addEventListener("click", () => {
          try { wasm.camera_zoom(-180); } catch (err) { console.error("camera_zoom failed", err); }
        });
        mapZoomOut?.addEventListener("click", () => {
          try { wasm.camera_zoom(180); } catch (err) { console.error("camera_zoom failed", err); }
        });
        mapMode?.addEventListener("click", () => {
          lockMode = lockMode === "auto" ? "orbit" : lockMode === "orbit" ? "pan" : "auto";
          syncMapToggles();
        });
        mapGraticule?.addEventListener("click", () => {
          toggleGraticule.checked = !toggleGraticule.checked;
          toggleGraticule.dispatchEvent(new Event("change"));
          syncMapToggles();
        });
        mapSun?.addEventListener("click", () => {
          toggleRealSun.checked = !toggleRealSun.checked;
          toggleRealSun.dispatchEvent(new Event("change"));
          syncMapToggles();
        });
        mapHelp?.addEventListener("click", () => {
          mapHelpText?.classList.toggle("hidden");
        });

        fileGeoJson.addEventListener("change", async () => {
          const file = fileGeoJson.files && fileGeoJson.files[0];
          if (!file) return;

          const MAX_GEOJSON_BYTES = 8 * 1024 * 1024;
          if (file.size > MAX_GEOJSON_BYTES) {
            setStatus(`Upload too large (max 8MiB): ${file.name}`);
            setUploadedInfo({
              error: `Upload too large for the web viewer (max 8MiB). File is ${file.size} bytes.`,
            });
            // allow re-uploading the same file
            fileGeoJson.value = "";
            return;
          }

          try {
            setStatus(`Loading ${file.name}…`);
            const text = await file.text();

            // Preflight in JS to avoid trapping the wasm module on overly complex GeoJSON.
            // This is intentionally conservative; the web viewer isn't meant for massive uploads.
            const MAX_FEATURES = 20_000;
            const MAX_COORD_PAIRS = 500_000;
            try {
              const geo = JSON.parse(text);
              if (geo && geo.type === "FeatureCollection" && Array.isArray(geo.features)) {
                let coordPairs = 0;

                function countPoint(pt) {
                  if (Array.isArray(pt) && pt.length >= 2) coordPairs += 1;
                }
                function countLine(line) {
                  if (!Array.isArray(line)) return;
                  for (const pt of line) countPoint(pt);
                }
                function countPolygon(poly) {
                  if (!Array.isArray(poly)) return;
                  for (const ring of poly) countLine(ring);
                }
                function countGeometry(g) {
                  if (!g || typeof g !== "object") return;
                  const t = g.type;
                  const c = g.coordinates;
                  if (t === "Point") countPoint(c);
                  else if (t === "MultiPoint") {
                    if (Array.isArray(c)) for (const pt of c) countPoint(pt);
                  } else if (t === "LineString") countLine(c);
                  else if (t === "MultiLineString") {
                    if (Array.isArray(c)) for (const line of c) countLine(line);
                  } else if (t === "Polygon") countPolygon(c);
                  else if (t === "MultiPolygon") {
                    if (Array.isArray(c)) for (const poly of c) countPolygon(poly);
                  } else if (t === "GeometryCollection") {
                    if (Array.isArray(g.geometries)) for (const gg of g.geometries) countGeometry(gg);
                  }
                }

                if (geo.features.length > MAX_FEATURES) {
                  throw new Error(`Too many features (${geo.features.length}). Max is ${MAX_FEATURES}.`);
                }

                for (const f of geo.features) {
                  countGeometry(f && f.geometry);
                  if (coordPairs > MAX_COORD_PAIRS) {
                    throw new Error(
                      `Too many coordinates (${coordPairs}). Max is ${MAX_COORD_PAIRS}.`
                    );
                  }
                }
              }
            } catch (preflightErr) {
              // If JSON parses but is too large/complex, stop before calling wasm.
              // If JSON is invalid, we also stop here with a clearer error.
              setStatus(`Upload rejected: ${file.name}`);
              setUploadedInfo({
                error: preflightErr?.message ?? String(preflightErr),
              });
              return;
            }

            const summary = await wasm.load_geojson_file(file.name, text);

            // Refresh catalog (upload is persisted in AVC form when it fits local storage).
            renderCatalog();

            setUploadedInfo({
              name: summary?.name ?? file.name,
              points: summary?.points ?? 0,
              lines: summary?.lines ?? 0,
              polygons: summary?.polygons ?? 0,
              catalog_persisted: summary?.catalog_persisted,
              catalog_error: summary?.catalog_error,
            });

            // Enable uploaded layers (if present) and label them.
            layerUploadedPointsLabel.textContent = `Uploaded points (${file.name})`;
            layerUploadedCorridorsLabel.textContent = `Uploaded lines (${file.name})`;
            layerUploadedRegionsLabel.textContent = `Uploaded polygons (${file.name})`;
            layerUploadedPoints.checked = (summary?.points ?? 0) > 0;
            layerUploadedCorridors.checked = (summary?.lines ?? 0) > 0;
            layerUploadedRegions.checked = (summary?.polygons ?? 0) > 0;

            if (summary?.catalog_persisted) {
              setStatus(`Uploaded & saved: ${file.name}`);
            } else {
              setStatus(`Uploaded (not saved to Catalog): ${file.name}`);
            }
          } catch (err) {
            console.error("GeoJSON upload failed", err);
            setStatus("Upload failed (see console)");
            setUploadedInfo({ error: err?.message ?? String(err) });
          } finally {
            // allow re-uploading the same file
            fileGeoJson.value = "";
          }
        });

        toggleGraticule.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_graticule_enabled(enabled);
          } catch (err) {
            console.error("set_graticule_enabled failed", err);
          }
          syncMapToggles();
        });

        toggleRealSun.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_real_time_sun_enabled(enabled);
          } catch (err) {
            console.error("set_real_time_sun_enabled failed", err);
          }
          syncMapToggles();
        });

        if (wasm.get_auto_rotate_settings) {
          try {
            const settings = wasm.get_auto_rotate_settings();
            if (settings) {
              if (toggleAutoRotate) toggleAutoRotate.checked = !!settings.enabled;
              if (autoRotateSpeed && settings.speed_deg_per_s !== undefined) {
                autoRotateSpeed.value = String(settings.speed_deg_per_s);
              }
              if (autoRotateSpeedValue && settings.speed_deg_per_s !== undefined) {
                autoRotateSpeedValue.textContent = Number(settings.speed_deg_per_s).toFixed(4);
              }
            }
          } catch (err) {
            console.error("get_auto_rotate_settings failed", err);
          }
        }

        toggleAutoRotate?.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_auto_rotate_enabled(enabled);
          } catch (err) {
            console.error("set_auto_rotate_enabled failed", err);
          }
        });

        autoRotateSpeed?.addEventListener("input", (e) => {
          const v = Number(e.target.value);
          if (autoRotateSpeedValue) autoRotateSpeedValue.textContent = v.toFixed(4);
          try {
            wasm.set_auto_rotate_speed_deg_per_s(v);
          } catch (err) {
            console.error("set_auto_rotate_speed_deg_per_s failed", err);
          }
        });

        function applyCitySize() {
          const v = Number(citySize.value);
          citySizeValue.textContent = String(v);
          try {
            wasm.set_city_marker_size(v);
          } catch (err) {
            console.error("set_city_marker_size failed", err);
          }
        }

        function applyLineWidth() {
          const v = Number(lineWidth.value);
          lineWidthValue.textContent = String(v);
          try {
            wasm.set_line_width_px(v);
          } catch (err) {
            console.error("set_line_width_px failed", err);
          }
        }

        citySize.addEventListener("input", applyCitySize);
        // Apply once at startup to sync wasm state.
        applyCitySize();

        lineWidth.addEventListener("input", applyLineWidth);
        applyLineWidth();

        syncMapToggles();

        // Panel toggle and resize functionality
        const PANEL_DEFAULT_WIDTH = 320;
        const PANEL_MIN_WIDTH = 280;
        const PANEL_MAX_WIDTH = 600;
        const PANEL_COLLAPSED_WIDTH = 52;
        
        const panel = document.getElementById("side-panel");
        const panelToggle = document.getElementById("panel-toggle");
        const resizeHandle = document.getElementById("panel-resize-handle");
        const app = document.getElementById("app");

        // Load saved panel state from localStorage
        const savedWidth = localStorage.getItem("panel-width");
        const savedCollapsed = localStorage.getItem("panel-collapsed") === "true";
        
        if (savedCollapsed) {
          panel.classList.add("collapsed");
          panelToggle.textContent = "▶";
          panelToggle.title = "Expand panel";
          app.style.setProperty("--panel-width", PANEL_COLLAPSED_WIDTH + "px");
        } else if (savedWidth) {
          app.style.setProperty("--panel-width", savedWidth + "px");
        } else {
          // Set default width explicitly for consistency
          app.style.setProperty("--panel-width", PANEL_DEFAULT_WIDTH + "px");
        }

        // Toggle panel collapse/expand
        panelToggle.addEventListener("click", () => {
          const isCollapsed = panel.classList.toggle("collapsed");
          panelToggle.textContent = isCollapsed ? "▶" : "◀";
          panelToggle.title = isCollapsed ? "Expand panel" : "Collapse panel";
          
          if (isCollapsed) {
            app.style.setProperty("--panel-width", PANEL_COLLAPSED_WIDTH + "px");
            localStorage.setItem("panel-collapsed", "true");
          } else {
            // Get the most recent width from localStorage
            const currentSavedWidth = localStorage.getItem("panel-width");
            const width = currentSavedWidth || PANEL_DEFAULT_WIDTH;
            app.style.setProperty("--panel-width", width + "px");
            localStorage.setItem("panel-collapsed", "false");
          }
          
          resizeCanvas(wasm);
        });

        // Resize functionality
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        const onMouseMove = (e) => {
          if (!isResizing) return;
          const delta = e.clientX - startX;
          const newWidth = Math.max(PANEL_MIN_WIDTH, Math.min(PANEL_MAX_WIDTH, startWidth + delta));
          app.style.setProperty("--panel-width", newWidth + "px");
        };

        const onMouseUp = () => {
          if (!isResizing) return;
          isResizing = false;
          resizeHandle.classList.remove("resizing");
          // Save the new width and resize canvas once
          const currentWidth = panel.offsetWidth;
          if (currentWidth > 0) {
            localStorage.setItem("panel-width", currentWidth.toString());
          }
          resizeCanvas(wasm);
          // Remove listeners to avoid unnecessary event handling
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };

        resizeHandle.addEventListener("mousedown", (e) => {
          if (panel.classList.contains("collapsed")) return;
          isResizing = true;
          startX = e.clientX;
          startWidth = panel.offsetWidth;
          resizeHandle.classList.add("resizing");
          e.preventDefault();
          // Add listeners only when resizing
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });

        setStatus("Controls: LMB drag=orbit, RMB/Shift+drag=pan, wheel=zoom, R=reset, click=pick");

        // Default view mode.
        applyViewMode("3d");
      }

      function bootstrap() {
        const alreadyLoaded = window.wasmBindings;
        if (alreadyLoaded) {
          main(alreadyLoaded);
          return;
        }

        window.addEventListener("TrunkApplicationStarted", () => {
          if (!window.wasmBindings) {
            console.error("Trunk started but wasmBindings missing");
            return;
          }
          main(window.wasmBindings);
        });
      }

      bootstrap();
    </script>
  </body>
</html>
