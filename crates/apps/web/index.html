<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Atlas Viewer (Web)</title>
    <link data-trunk rel="rust" data-wasm-opt="z" />
    <link data-trunk rel="copy-dir" href="assets" />
    <style>
      :root {
        --bg: #020617;
        --fg: #e2e8f0;
        --muted: #94a3b8;
        --panel-bg: #0b132b;
        --panel-border: #1f2a44;
        --section-bg: #0f172a;
        --btn-bg: #111827;
        --btn-fg: #e5e7eb;
        --btn-border: #1f2a44;
        --btn-hover-bg: #111827;
        --accent: #2563eb;
        --accent-border: #3b82f6;
        --info: #93c5fd;
        --success: #86efac;
        --warning: #fbbf24;
        --danger: #fca5a5;
        --controls-bg: rgba(15, 23, 42, 0.72);
        --controls-border: rgba(31, 42, 68, 0.90);
        --shadow: rgba(2, 6, 23, 0.55);
      }
      html[data-theme="dark"] {
        --bg: #020617;
        --fg: #e2e8f0;
        --muted: #94a3b8;
        --panel-bg: #0b132b;
        --panel-border: #1f2a44;
        --section-bg: #0f172a;
        --btn-bg: #111827;
        --btn-fg: #e5e7eb;
        --btn-border: #1f2a44;
        --btn-hover-bg: #111827;
        --accent: #2563eb;
        --accent-border: #3b82f6;
        --controls-bg: rgba(15, 23, 42, 0.72);
        --controls-border: rgba(31, 42, 68, 0.90);
        --shadow: rgba(2, 6, 23, 0.55);
      }
      html[data-theme="deep-dark"] {
        --bg: #000000;
        --fg: #f1f5f9;
        --muted: #a1a1aa;
        --panel-bg: #05070c;
        --panel-border: #141a2a;
        --section-bg: #070b14;
        --btn-bg: #0b1220;
        --btn-fg: #f1f5f9;
        --btn-border: #141a2a;
        --btn-hover-bg: #0f172a;
        --accent: #2563eb;
        --accent-border: #60a5fa;
        --controls-bg: rgba(2, 6, 23, 0.80);
        --controls-border: rgba(30, 41, 59, 0.75);
        --shadow: rgba(0, 0, 0, 0.75);
      }
      html[data-theme="light"] {
        --bg: #f8fafc;
        --fg: #0f172a;
        --muted: #475569;
        --panel-bg: #ffffff;
        --panel-border: #e2e8f0;
        --section-bg: #f1f5f9;
        --btn-bg: #ffffff;
        --btn-fg: #0f172a;
        --btn-border: #cbd5e1;
        --btn-hover-bg: #f1f5f9;
        --accent: #2563eb;
        --accent-border: #1d4ed8;
        --controls-bg: rgba(255, 255, 255, 0.80);
        --controls-border: rgba(203, 213, 225, 0.85);
        --shadow: rgba(15, 23, 42, 0.15);
        --info: #1d4ed8;
        --success: #15803d;
        --warning: #a16207;
        --danger: #b91c1c;
      }

      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: var(--bg);
        color: var(--fg);
        font-family: "Inter", "JetBrains Mono", system-ui, sans-serif;
      }
      #app {
        width: 100%;
        height: 100%;
        position: relative;
        display: block;
        --panel-width: 320px;
      }
      #side-panel {
        background: var(--controls-bg);
        border: 1px solid var(--controls-border);
        backdrop-filter: blur(10px);
        border-radius: 12px;
        box-shadow: 0 12px 24px var(--shadow);
        padding: 14px;
        display: flex;
        flex-direction: column;
        gap: 14px;
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        height: calc(100vh - 24px);
        width: var(--panel-width);
        max-width: 600px;
        overflow-y: auto;
        overflow-x: hidden;
        transition: transform 0.2s ease, width 0.15s ease;
        z-index: 20;
      }
      #panel-toggle {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 34px;
        height: 34px;
        padding: 0;
        border-radius: 10px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        cursor: pointer;
        display: grid;
        place-items: center;
      }
      #panel-toggle:hover {
        background: var(--btn-hover-bg);
        border-color: var(--accent-border);
      }
      #panel-resize-handle {
        display: block;
        position: absolute;
        top: 10px;
        right: -6px;
        width: 12px;
        height: calc(100% - 20px);
        cursor: ew-resize;
        border-radius: 8px;
      }
      #panel-resize-handle:hover {
        background: rgba(59, 130, 246, 0.3);
      }
      #panel-resize-handle.resizing {
        background: rgba(59, 130, 246, 0.5);
      }
      .tabs {
        display: flex;
        gap: 8px;
      }
      .panel-tabs {
        display: flex;
      }
      #side-panel.collapsed {
        width: 52px !important;
        padding: 10px;
        overflow: hidden;
      }
      #side-panel.collapsed #panel-resize-handle {
        display: none;
      }
      #side-panel.collapsed .panel-tabs,
      #side-panel.collapsed .tab-page,
      #side-panel.collapsed #compact-panel-close {
        display: none;
      }
      .tab-btn {
        flex: 1;
        padding: 8px 10px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
      }
      .tab-btn.active {
        background: var(--accent);
        border-color: var(--accent-border);
      }
      .tab-page.hidden { display: none; }
      #atlas-canvas-2d,
      #atlas-canvas-3d {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
        touch-action: none;
      }
      #atlas-canvas-3d { z-index: 1; }
      #atlas-canvas-2d { z-index: 2; }
      #atlas-canvas-2d.hidden,
      #atlas-canvas-3d.hidden {
        display: none;
      }
      #map-area {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      .map-controls {
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        z-index: 30;
        display: flex;
        flex-direction: column;
        gap: 8px;
        padding: 0;
        border: none;
        background: transparent;
        backdrop-filter: none;
        border-radius: 0;
        user-select: none;
        z-index: 10;
      }
      .map-controls-row {
        display: flex;
        gap: 8px;
        align-items: center;
        justify-content: flex-end;
        padding-bottom: 0;
        border-bottom: none;
        margin-bottom: 0;
      }
      .map-controls[data-pos="left"] {
        left: 12px;
        right: auto;
      }
      .map-controls[data-pos="right"] {
        right: 12px;
        left: auto;
      }
      .map-controls .btn {
        width: 38px;
        height: 38px;
        padding: 0;
        margin: 0;
        border-radius: 10px;
        display: grid;
        place-items: center;
        font-weight: 800;
        line-height: 1;
        background: transparent;
        border: 1px solid var(--controls-border);
        box-shadow: 0 12px 24px var(--shadow);
      }
      .map-controls .btn.active {
        border-color: var(--accent-border);
      }
      .map-controls .btn:hover {
        border-color: var(--accent-border);
        box-shadow: 0 16px 28px var(--shadow);
      }
      .map-controls .btn.small {
        width: 38px;
        height: 30px;
        font-weight: 700;
        font-size: 12px;
      }
      #map-compass {
        width: 38px;
        height: 38px;
        border-radius: 999px;
        position: relative;
        padding: 0;
      }
      #map-compass .compass-label {
        position: absolute;
        top: 6px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 11px;
        font-weight: 900;
        color: var(--btn-fg);
        letter-spacing: 0.5px;
        pointer-events: none;
      }
      #compass-needle {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 2px;
        height: 13px;
        background: #ef4444;
        border-radius: 2px;
        transform-origin: 50% 100%;
        transform: translate(-50%, -100%) rotate(0deg);
        pointer-events: none;
      }
      .map-controls .hint {
        max-width: 220px;
        font-size: 12px;
        color: color-mix(in srgb, var(--fg) 80%, var(--muted));
        line-height: 1.35;
      }
      .map-controls .hint.hidden {
        display: none;
      }
      .section {
        border: 1px solid var(--panel-border);
        border-radius: 8px;
        padding: 12px;
        background: var(--section-bg);
      }
      .section h3 {
        margin: 0 0 8px 0;
        font-size: 14px;
        letter-spacing: 0.3px;
        color: var(--info);
      }
      label { display: block; margin-bottom: 8px; font-size: 13px; color: color-mix(in srgb, var(--fg) 80%, var(--muted)); }
      select, button, input[type="checkbox"] {
        font-size: 13px;
      }
      button {
        padding: 8px 10px;
        margin-right: 6px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        border-radius: 6px;
        cursor: pointer;
      }
      button.active { background: var(--accent); border-color: var(--accent-border); }
      select { width: 100%; padding: 6px; border-radius: 6px; border: 1px solid var(--btn-border); background: var(--btn-bg); color: var(--btn-fg); }
      .checkbox { display: flex; gap: 8px; align-items: center; }
      .row { display: flex; align-items: center; gap: 10px; }
      input[type="range"] { width: 100%; }
      .value { font-variant-numeric: tabular-nums; color: color-mix(in srgb, var(--fg) 80%, var(--muted)); font-size: 12px; }
      .layer-row {
        display: grid;
        grid-template-columns: 1fr 44px 1fr 1fr;
        gap: 10px;
        align-items: center;
        margin-top: 8px;
      }
      .layer-row .mini { font-size: 11px; color: var(--muted); }

      .muted { color: var(--muted); }
      .sr-only {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
      }
      .icon {
        width: 18px;
        height: 18px;
        display: inline-block;
      }
      .icon svg {
        width: 100%;
        height: 100%;
        display: block;
      }
      .icon svg * { stroke: currentColor; }

      .compact-tabs {
        position: absolute;
        top: 12px;
        left: 12px;
        right: auto;
        transform: none;
        display: none;
        flex-direction: column;
        gap: 8px;
        padding: 0;
        border: none;
        background: transparent;
        backdrop-filter: none;
        border-radius: 0;
        z-index: 18;
      }
      .compact-tabs .btn {
        width: 40px;
        height: 40px;
        border-radius: 12px;
        padding: 0;
        margin: 0;
        display: grid;
        place-items: center;
        font-weight: 800;
        border: 1px solid var(--controls-border);
        background: transparent;
        backdrop-filter: none;
        box-shadow: 0 12px 24px var(--shadow);
      }
      .compact-tabs .btn.active {
        border-color: var(--accent-border);
      }
      .compact-tabs .btn:hover {
        border-color: var(--accent-border);
        box-shadow: 0 16px 28px var(--shadow);
      }
      .compact-close {
        display: none;
        position: absolute;
        top: 12px;
        right: 12px;
        width: 32px;
        height: 32px;
        border-radius: 8px;
        font-weight: 700;
        z-index: 30;
      }

      @media (max-width: 900px) {
        #side-panel {
          width: min(92vw, 380px);
          transform: translateX(calc(-100% - 24px));
        }
        #side-panel.compact-open {
          transform: translateX(0);
        }
        .compact-tabs { display: flex; }
        .compact-close {
          display: inline-flex;
          align-items: center;
          justify-content: center;
        }
      }

      /* Glassy modal used for feeds + other map overlays. */
      .modal-backdrop {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(2, 6, 23, 0.40);
        backdrop-filter: blur(12px);
        z-index: 40;
      }
      .modal-backdrop.hidden { display: none; }
      .modal {
        width: min(92vw, 560px);
        max-height: min(82vh, 720px);
        overflow: auto;
        background: rgba(15, 23, 42, 0.72);
        border: 1px solid rgba(148, 163, 184, 0.18);
        border-radius: 14px;
        box-shadow: 0 18px 44px rgba(0, 0, 0, 0.35);
        padding: 14px;
      }
      .modal h3 { margin: 0; }
      .modal .modal-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
      }
      .modal .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 8px;
        margin-top: 12px;
      }
      .modal .grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      .modal .row {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 3px 8px;
        border-radius: 999px;
        border: 1px solid rgba(148, 163, 184, 0.18);
        background: rgba(2, 6, 23, 0.35);
        font-size: 11px;
        color: var(--muted);
      }

      /* Perf HUD (transparent, theme-friendly) */
      .perf-hud {
        position: absolute;
        right: 12px;
        bottom: 12px;
        z-index: 15;
        max-width: min(520px, calc(100vw - 24px));
        background: color-mix(in srgb, var(--controls-bg) 86%, transparent);
        border: 1px solid var(--controls-border);
        border-radius: 12px;
        box-shadow: 0 12px 24px var(--shadow);
        backdrop-filter: blur(10px);
        padding: 10px 12px;
        user-select: none;
        pointer-events: none; /* don't block map input */
      }
      .perf-hud.hidden { display: none; }
      .perf-hud .hdr {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 6px;
      }
      .perf-hud .title {
        font-size: 12px;
        font-weight: 800;
        letter-spacing: 0.02em;
        color: var(--fg);
        opacity: 0.92;
      }
      .perf-hud .hint {
        font-size: 11px;
        color: var(--muted);
        opacity: 0.9;
      }
      .perf-hud pre {
        margin: 0;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 11px;
        line-height: 1.35;
        color: var(--fg);
        white-space: pre;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      /* ── Time Dial ────────────────────────────────────────────── */
      .time-dial {
        position: fixed;
        top: 8px;
        left: 50vw;
        transform: translateX(-50%);
        z-index: 25;
        display: flex;
        align-items: center;
        gap: 0;
        height: 30px;
        background: var(--controls-bg);
        border: 1px solid var(--controls-border);
        backdrop-filter: blur(10px);
        border-radius: 10px;
        box-shadow: 0 4px 16px var(--shadow);
        user-select: none;
        padding: 0;
        min-width: 380px;
        max-width: min(720px, calc(100vw - 100px));
        overflow: visible;
        pointer-events: auto;
      }
      .time-dial.hidden { display: none; }

      .time-dial-playback {
        display: flex;
        align-items: center;
        gap: 2px;
        padding: 0 4px;
        flex-shrink: 0;
      }
      .time-dial-playback .td-btn {
        width: 22px;
        height: 22px;
        padding: 0;
        border-radius: 6px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        cursor: pointer;
        display: grid;
        place-items: center;
        font-size: 11px;
        line-height: 1;
      }
      .time-dial-playback .td-btn:hover {
        border-color: var(--accent-border);
      }
      .time-dial-playback .td-btn.active {
        background: var(--accent);
        border-color: var(--accent-border);
      }

      .time-dial-track-wrapper {
        position: relative;
        flex: 1;
        height: 100%;
        overflow: hidden;
        cursor: grab;
      }
      .time-dial-track-wrapper:active { cursor: grabbing; }
      .time-dial-track {
        position: relative;
        width: 100%;
        height: 100%;
      }
      .time-dial-canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      /* Center needle */
      .time-dial-needle {
        position: absolute;
        top: 3px;
        bottom: 3px;
        left: 50%;
        transform: translateX(-50%);
        width: 2px;
        background: var(--accent-border);
        border-radius: 2px;
        pointer-events: none;
        z-index: 2;
      }
      .time-dial-needle::after {
        content: '';
        position: absolute;
        top: -2px;
        left: 50%;
        transform: translateX(-50%);
        width: 0;
        height: 0;
        border-left: 4px solid transparent;
        border-right: 4px solid transparent;
        border-top: 4px solid var(--accent-border);
      }

      .time-dial-label {
        position: absolute;
        bottom: -16px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 10px;
        font-weight: 700;
        color: var(--accent-border);
        white-space: nowrap;
        pointer-events: none;
        text-shadow: 0 1px 4px var(--shadow);
        z-index: 3;
      }

      .time-dial-settings-btn {
        width: 24px;
        height: 24px;
        padding: 0;
        border-radius: 6px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        cursor: pointer;
        display: grid;
        place-items: center;
        margin: 0 4px;
        flex-shrink: 0;
      }
      .time-dial-settings-btn:hover {
        border-color: var(--accent-border);
      }
      .time-dial-settings-btn svg {
        width: 13px;
        height: 13px;
      }
      .time-dial-settings-btn svg * { stroke: currentColor; }

      /* Speed label inside the dial */
      .time-dial-speed {
        font-size: 9px;
        font-weight: 700;
        color: var(--muted);
        padding: 0 3px;
        flex-shrink: 0;
        white-space: nowrap;
      }

      /* Responsive: shrink on narrow viewports */
      @media (max-width: 900px) {
        .time-dial {
          min-width: 300px;
          max-width: min(600px, calc(100vw - 100px));
        }
      }
      @media (max-width: 600px) {
        .time-dial {
          min-width: 240px;
          max-width: calc(100vw - 24px);
          top: 6px;
          height: 28px;
          border-radius: 8px;
        }
        .time-dial-playback .td-btn {
          width: 20px;
          height: 20px;
          font-size: 10px;
        }
        .time-dial-settings-btn {
          width: 20px;
          height: 20px;
        }
      }

      /* Time settings modal extends the existing .modal style */
      .time-settings-modal .ts-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }
      .time-settings-modal .ts-grid.full {
        grid-template-columns: 1fr;
      }
      .time-settings-modal label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 2px;
      }
      .time-settings-modal input[type="text"],
      .time-settings-modal input[type="number"],
      .time-settings-modal input[type="datetime-local"],
      .time-settings-modal select {
        width: 100%;
        padding: 6px 8px;
        border-radius: 6px;
        border: 1px solid var(--btn-border);
        background: var(--btn-bg);
        color: var(--btn-fg);
        font-size: 13px;
      }
      .time-settings-modal .layer-time-list {
        max-height: 220px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 8px;
      }
      .time-settings-modal .layer-time-row {
        display: grid;
        grid-template-columns: auto 1fr auto;
        gap: 8px;
        align-items: center;
        padding: 6px 8px;
        border-radius: 6px;
        background: rgba(2, 6, 23, 0.25);
        border: 1px solid rgba(148, 163, 184, 0.10);
      }
      .time-settings-modal .layer-time-row .lt-name {
        font-size: 12px;
        font-weight: 600;
      }
      .time-settings-modal .layer-time-row select {
        max-width: 160px;
      }
    </style>
    <script>
      // Apply theme as early as possible to avoid a flash.
      (function () {
        try {
          const saved = String(localStorage.getItem("atlas-theme") || "").trim();
          const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
          const theme = saved || (prefersLight ? "light" : "dark");
          document.documentElement.dataset.theme = theme;
        } catch (_) {
          document.documentElement.dataset.theme = "dark";
        }
      })();
    </script>
  </head>
  <body>
    <div id="app">
      <div id="side-panel">
        <button id="panel-toggle" type="button" title="Collapse panel">◀</button>
        <button id="compact-panel-close" class="compact-close" type="button" title="Close panel">✕</button>
        <div id="panel-resize-handle"></div>
        <div class="panel-tabs">
          <button id="tab-general-btn" class="tab-btn active" type="button">General</button>
          <button id="tab-layers-btn" class="tab-btn" type="button">Layers</button>
          <button id="tab-feeds-btn" class="tab-btn" type="button">Feeds</button>
          <button id="tab-catalog-btn" class="tab-btn" type="button">Catalog</button>
          <button id="tab-settings-btn" class="tab-btn" type="button">Settings</button>
        </div>

        <div id="tab-general" class="tab-page">
          <div class="section">
            <h3>Mode</h3>
            <div class="tabs">
              <button id="mode-2d" class="tab-btn" type="button">2D</button>
              <button id="mode-3d" class="tab-btn active" type="button">3D</button>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Switches the active surface. Layers stay the same.
            </div>
          </div>

          <div class="section">
            <h3>Upload</h3>
            <label for="file-geojson">Upload GIS file (GeoJSON)</label>
            <input id="file-geojson" type="file" accept=".json,.geojson,application/geo+json,application/json" />
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Supports GeoJSON FeatureCollection/Feature/bare geometry with Point/LineString/Polygon (+ Multi*).
            </div>
            <div id="uploaded-info" style="margin-top:10px; font-size:12px; color:#cbd5e1; line-height:1.35;">
              <div style="color:var(--muted);">No upload loaded.</div>
            </div>
          </div>
          <div class="section">
            <h3>Overlays</h3>
            <label class="checkbox">
              <input id="toggle-graticule" type="checkbox" />
              <span>Show graticule</span>
            </label>
          </div>
          <div class="section">
            <h3>Status</h3>
            <div id="status-text" style="font-size:12px; color:#cbd5e1;">Ready</div>
            <div id="surface-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Surface: idle</div>
            <div id="dem-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Terrain (backend): unknown</div>
            <div id="terrain-client-status-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Terrain (client): idle</div>
            <div id="cursor-text" style="font-size:12px; color:var(--muted); margin-top:6px;">Cursor: —</div>
            <div id="pick-text" style="font-size:12px; color:var(--muted); margin-top:2px;">Pick: —</div>
          </div>

          <div class="section">
            <h3>Surface</h3>
            <label class="checkbox">
              <input id="surface-use-pmtiles" type="checkbox" />
              <span>Use lightweight PMTiles base surface</span>
            </label>
            <label for="surface-pmtiles-max-zoom" style="margin-top:8px;">PMTiles refinement max zoom</label>
            <div class="row">
              <input id="surface-pmtiles-max-zoom" type="range" min="0" max="5" step="1" value="3" />
              <span id="surface-pmtiles-max-zoom-value" class="value">3</span>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Loads z0 immediately, then refines up to the max zoom. Higher zoom = more detail + more requests.
            </div>
          </div>
        </div>

        <div id="tab-layers" class="tab-page hidden">
          <div class="section">
            <h3>Points</h3>
            <label for="city-size">Point size (px)</label>
            <div class="row">
              <input id="city-size" type="range" min="1" max="24" step="1" value="4" />
              <span id="city-size-value" class="value">4</span>
            </div>
          </div>

          <div class="section">
            <h3>Lines</h3>
            <label for="line-width">Line width (px)</label>
            <div class="row">
              <input id="line-width" type="range" min="1" max="16" step="0.5" value="2.5" />
              <span id="line-width-value" class="value">2.5</span>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Note: this viewer uses simple per-layer styles (color/opacity/lift/width), not rule-based GIS symbology.
            </div>
          </div>

          <div class="section">
            <h3>Layers</h3>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-world-base" type="checkbox" checked />
                <span>World base (built-in)</span>
              </label>
              <input id="layer-world-base-color" type="color" value="#33a85a" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-world-base-opacity" type="range" min="0" max="1" step="0.01" value="1.00" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-world-base-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-terrain" type="checkbox" />
                <span>3D terrain mesh (streaming)</span>
              </label>
              <div class="muted" style="font-size:12px;">Loads on-demand tiles when enabled.</div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-cities" type="checkbox" />
                <span>Cities (built-in)</span>
              </label>
              <input id="layer-cities-color" type="color" value="#ff4040" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-cities-opacity" type="range" min="0" max="1" step="0.01" value="0.95" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-cities-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-corridors" type="checkbox" />
                <span>Air corridors (built-in)</span>
              </label>
              <input id="layer-corridors-color" type="color" value="#ffd640" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-corridors-opacity" type="range" min="0" max="1" step="0.01" value="0.90" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-corridors-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-regions" type="checkbox" />
                <span>Regions (built-in)</span>
              </label>
              <input id="layer-regions-color" type="color" value="#19e6bf" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-regions-opacity" type="range" min="0" max="1" step="0.01" value="0.30" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-regions-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-points" type="checkbox" />
                <span id="layer-uploaded-points-label">Uploaded points</span>
              </label>
              <input id="layer-uploaded-points-color" type="color" value="#99f2ff" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-points-opacity" type="range" min="0" max="1" step="0.01" value="0.95" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-points-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-corridors" type="checkbox" />
                <span id="layer-uploaded-corridors-label">Uploaded lines</span>
              </label>
              <input id="layer-uploaded-corridors-color" type="color" value="#d9f299" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-corridors-opacity" type="range" min="0" max="1" step="0.01" value="0.90" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-corridors-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div class="layer-row">
              <label class="checkbox">
                <input id="layer-uploaded-regions" type="checkbox" />
                <span id="layer-uploaded-regions-label">Uploaded polygons</span>
              </label>
              <input id="layer-uploaded-regions-color" type="color" value="#73b7ff" />
              <div>
                <div class="mini">Opacity</div>
                <input id="layer-uploaded-regions-opacity" type="range" min="0" max="1" step="0.01" value="0.25" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input id="layer-uploaded-regions-lift" type="range" min="-0.02" max="0.05" step="0.001" value="0.00" />
              </div>
            </div>

            <div style="margin-top:12px; padding-top:12px; border-top:1px solid rgba(148, 163, 184, 0.14);">
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:800;">Feed layers</div>
                <span class="pill">dynamic</span>
              </div>
              <div id="feed-layer-controls" style="display:flex; flex-direction:column; gap:10px; margin-top:10px;"></div>
              <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
                Online feeds you add in the Feeds tab will show up here as point layers.
              </div>
            </div>

            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:10px;">
              Tip: you can enable multiple layers at once. Click on a point layer to pick the nearest marker.
            </div>
          </div>
        </div>

        <div id="tab-feeds" class="tab-page hidden">
          <div class="section">
            <h3>Online feeds</h3>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-bottom:10px;">
              Add public CSV/JSON/RSS feeds and render them as point layers. Feeds are fetched via the Atlas backend (to avoid browser CORS limitations).
            </div>
            <div id="feeds-backend-hint" class="muted" style="font-size:12px; line-height:1.35; margin-bottom:10px;"></div>
            <div class="row" style="gap:8px;">
              <button id="feed-add-btn" type="button">Add feed…</button>
              <button id="feed-sample-btn" type="button" class="btn" title="Add the provided sample CSV feed">Add sample</button>
              <button id="feeds-refresh-all" type="button" class="btn" title="Refetch all feeds">Refresh all</button>
            </div>
            <div id="feeds-list" style="display:flex; flex-direction:column; gap:10px; margin-top:12px;"></div>
            <div id="feeds-empty" class="muted" style="font-size:12px; line-height:1.35; margin-top:10px;">
              No feeds yet. Click “Add feed…” to get started.
            </div>
          </div>
        </div>

        <div id="tab-catalog" class="tab-page hidden">
          <div class="section">
            <h3>Catalog</h3>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-bottom:10px;">
              Uploaded layers are stored locally (in AVC format) and listed here. Built-ins are listed as read-only.
            </div>
            <div id="catalog-list" style="display:flex; flex-direction:column; gap:10px;"></div>
            <div id="catalog-empty" class="muted" style="font-size:12px; line-height:1.35;">
              No catalog entries yet. Upload a GeoJSON file in the General tab.
            </div>
          </div>
        </div>

        <div id="tab-settings" class="tab-page hidden">
          <div class="section">
            <h3>Appearance</h3>
            <label for="theme-select">Theme</label>
            <select id="theme-select">
              <option value="dark">Dark</option>
              <option value="deep-dark">Deep Dark</option>
              <option value="light">Light</option>
            </select>
            <label class="checkbox" style="margin-top:10px;">
              <input id="toggle-globe-transparent" type="checkbox" />
              <span>Transparent globe</span>
            </label>
            <label class="checkbox" style="margin-top:8px;">
              <input id="toggle-time-dial" type="checkbox" checked />
              <span>Show time dial</span>
            </label>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:8px;">
              Affects UI and globe colors (base surface + ocean/space).
            </div>
          </div>

          <div class="section">
            <h3>Diagnostics</h3>
            <label class="checkbox">
              <input id="toggle-perf-hud" type="checkbox" />
              <span>Show performance HUD (P)</span>
            </label>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:6px;">
              Shows per-frame WebGPU counters (uploads/draw calls) and 2D timings.
            </div>
          </div>
          <div class="section">
            <h3>Lighting</h3>
            <label class="checkbox">
              <input id="toggle-real-sun" type="checkbox" checked />
              <span>Real-time sun shadows</span>
            </label>
            <div class="muted" style="font-size:12px; line-height:1.35;">
              Syncs the globe lighting to your current system time.
            </div>
          </div>
          <div class="section">
            <h3>Globe rotation</h3>
            <label class="checkbox">
              <input id="toggle-auto-rotate" type="checkbox" checked />
              <span>Auto-rotate globe</span>
            </label>
            <label for="auto-rotate-speed" style="margin-top:8px;">Rotation speed (deg/s)</label>
            <div class="row">
              <input id="auto-rotate-speed" type="range" min="0" max="2" step="0.01" value="0.15" />
              <span id="auto-rotate-speed-value" class="value">0.15</span>
            </div>
          </div>
          <div class="section">
            <h3>File Upload</h3>
            <label for="upload-size-limit">Max upload size (MB)</label>
            <div class="row">
              <input id="upload-size-limit" type="range" min="1" max="1024" step="1" value="1024" />
              <span id="upload-size-limit-value" class="value">8</span>
            </div>
            <label for="max-coord-pairs" style="margin-top:8px;">Max coordinates (thousands)</label>
            <div class="row">
              <input id="max-coord-pairs" type="range" min="100" max="10000" step="100" value="10000" />
              <span id="max-coord-pairs-value" class="value">10000k</span>
            </div>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-top:4px;">
              Limits for GeoJSON/CSV uploads. Larger values may slow down the browser.
            </div>
          </div>

          <div class="section">
            <h3>Controls</h3>
            <div class="muted" style="font-size:12px; line-height:1.35; margin-bottom:8px;">
              <strong>Left drag:</strong> rotate globe / pan map<br/>
              <strong>Right drag / Shift+drag:</strong> translate globe / pan map<br/>
              <strong>Wheel:</strong> zoom &nbsp; <strong>R:</strong> reset camera
            </div>

            <label for="ctrl-orbit-sens">3D orbit sensitivity</label>
            <div class="row">
              <input id="ctrl-orbit-sens" type="range" min="0.1" max="3" step="0.05" value="1" />
              <span id="ctrl-orbit-sens-value" class="value">1.0</span>
            </div>

            <label for="ctrl-pan-sens-3d" style="margin-top:6px;">3D pan sensitivity</label>
            <div class="row">
              <input id="ctrl-pan-sens-3d" type="range" min="0.1" max="3" step="0.05" value="1" />
              <span id="ctrl-pan-sens-3d-value" class="value">1.0</span>
            </div>

            <label for="ctrl-zoom-speed-3d" style="margin-top:6px;">3D zoom speed</label>
            <div class="row">
              <input id="ctrl-zoom-speed-3d" type="range" min="0.1" max="3" step="0.05" value="1" />
              <span id="ctrl-zoom-speed-3d-value" class="value">1.0</span>
            </div>

            <label for="ctrl-pan-sens-2d" style="margin-top:6px;">2D pan sensitivity</label>
            <div class="row">
              <input id="ctrl-pan-sens-2d" type="range" min="0.1" max="3" step="0.05" value="1" />
              <span id="ctrl-pan-sens-2d-value" class="value">1.0</span>
            </div>

            <label for="ctrl-zoom-speed-2d" style="margin-top:6px;">2D zoom speed</label>
            <div class="row">
              <input id="ctrl-zoom-speed-2d" type="range" min="0.1" max="3" step="0.05" value="1" />
              <span id="ctrl-zoom-speed-2d-value" class="value">1.0</span>
            </div>

            <label class="checkbox" style="margin-top:8px;">
              <input id="ctrl-invert-orbit-y" type="checkbox" />
              <span>Invert orbit Y axis</span>
            </label>
            <label class="checkbox" style="margin-top:4px;">
              <input id="ctrl-invert-pan-y-3d" type="checkbox" />
              <span>Invert 3D pan Y axis</span>
            </label>
            <label class="checkbox" style="margin-top:4px;">
              <input id="ctrl-invert-pan-y-2d" type="checkbox" />
              <span>Invert 2D pan Y axis</span>
            </label>
            <label class="checkbox" style="margin-top:4px;">
              <input id="ctrl-kinetic-pan" type="checkbox" checked />
              <span>Kinetic panning (2D inertia)</span>
            </label>

            <button id="ctrl-reset-defaults" class="btn" type="button" style="margin-top:10px; width: 100%; height:30px; border-radius:8px;">
              Reset controls to defaults
            </button>
          </div>
        </div>
      </div>
      <div id="map-area">
        <canvas id="atlas-canvas-2d" width="1280" height="720" class="hidden"></canvas>
        <canvas id="atlas-canvas-3d" width="1280" height="720"></canvas>

        <!-- ── Time Dial ──────────────────────────────────────── -->
        <div id="time-dial" class="time-dial" aria-label="Time dial">
          <div class="time-dial-playback">
            <button id="td-step-back" class="td-btn" type="button" title="Step backward">⏪</button>
            <button id="td-play" class="td-btn" type="button" title="Play / Pause">▶</button>
            <button id="td-step-fwd" class="td-btn" type="button" title="Step forward">⏩</button>
          </div>
          <div id="td-track-wrapper" class="time-dial-track-wrapper">
            <canvas id="td-canvas" class="time-dial-canvas"></canvas>
            <div class="time-dial-needle"></div>
            <div id="td-label" class="time-dial-label">00:00:00</div>
          </div>
          <span id="td-speed" class="time-dial-speed">1×</span>
          <button id="td-settings-btn" class="time-dial-settings-btn" type="button" title="Time settings">
            <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z"/>
              <path d="M19.4 15a7.8 7.8 0 0 0 .1-1 7.8 7.8 0 0 0-.1-1l2-1.6-2-3.4-2.4 1a8.4 8.4 0 0 0-1.7-1l-.4-2.6H9.1L8.7 7a8.4 8.4 0 0 0-1.7 1l-2.4-1-2 3.4L4.6 13a7.8 7.8 0 0 0-.1 1 7.8 7.8 0 0 0 .1 1l-2 1.6 2 3.4 2.4-1a8.4 8.4 0 0 0 1.7 1l.4 2.6h5.8l.4-2.6a8.4 8.4 0 0 0 1.7-1l2.4 1 2-3.4-2-1.6z"/>
            </svg>
          </button>
        </div>

        <!-- ── Time Settings Modal ────────────────────────────── -->
        <div id="time-settings-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Time settings">
          <div class="modal time-settings-modal">
            <div class="modal-header">
              <h3>Time Settings</h3>
              <button id="ts-modal-close" type="button" class="btn" title="Close">✕</button>
            </div>

            <div style="display:flex; flex-direction:column; gap:14px;">
              <div class="section">
                <h3>Time Range</h3>
                <div class="ts-grid">
                  <div>
                    <label for="ts-mode">Time mode</label>
                    <select id="ts-mode">
                      <option value="relative" selected>Relative (seconds)</option>
                      <option value="absolute">Absolute (date/time)</option>
                    </select>
                  </div>
                  <div>
                    <label for="ts-speed">Playback speed</label>
                    <select id="ts-speed">
                      <option value="0.25">0.25×</option>
                      <option value="0.5">0.5×</option>
                      <option value="1" selected>1×</option>
                      <option value="2">2×</option>
                      <option value="5">5×</option>
                      <option value="10">10×</option>
                      <option value="30">30×</option>
                      <option value="60">60×</option>
                    </select>
                  </div>
                </div>
                <div class="ts-grid" style="margin-top:10px;">
                  <div>
                    <label for="ts-start">Start</label>
                    <input id="ts-start" type="text" placeholder="0" value="0" />
                  </div>
                  <div>
                    <label for="ts-end">End</label>
                    <input id="ts-end" type="text" placeholder="10" value="10" />
                  </div>
                </div>
                <div class="ts-grid" style="margin-top:10px;">
                  <div>
                    <label for="ts-step">Step size (seconds)</label>
                    <input id="ts-step" type="number" min="0.001" step="0.001" value="0.016" />
                  </div>
                  <div>
                    <label for="ts-loop">Loop playback</label>
                    <select id="ts-loop">
                      <option value="loop" selected>Loop</option>
                      <option value="once">Play once</option>
                      <option value="bounce">Bounce (ping-pong)</option>
                    </select>
                  </div>
                </div>
              </div>

              <div class="section">
                <h3>Layer Time Settings</h3>
                <div class="muted" style="font-size:12px; line-height:1.35; margin-bottom:8px;">
                  Enable time-filtering on layers. Choose which attribute field drives temporal visibility.
                </div>
                <div id="ts-layer-list" class="layer-time-list">
                  <div class="muted" style="font-size:12px;">No layers loaded yet.</div>
                </div>
              </div>

              <div class="section">
                <h3>Display</h3>
                <div class="ts-grid">
                  <div>
                    <label for="ts-format">Time label format</label>
                    <select id="ts-format">
                      <option value="wallclock" selected>Wall clock (real time)</option>
                      <option value="seconds">Seconds (0.00s)</option>
                      <option value="hms">HH:MM:SS</option>
                      <option value="datetime">Date/Time</option>
                    </select>
                  </div>
                  <div>
                    <label for="ts-divisions">Tick interval (seconds)</label>
                    <input id="ts-divisions" type="number" min="0.1" step="0.1" value="1" />
                  </div>
                </div>
                <label class="checkbox" style="margin-top:8px;">
                  <input id="ts-show-dial" type="checkbox" checked />
                  <span>Show time dial on map</span>
                </label>
              </div>
            </div>

            <div class="modal-footer">
              <button id="ts-reset-btn" type="button" class="btn">Reset defaults</button>
              <button id="ts-save-btn" type="button">Save</button>
            </div>
          </div>
        </div>

        <div id="perf-hud" class="perf-hud hidden" aria-label="Performance HUD">
          <div class="hdr">
            <div class="title">Perf</div>
            <div class="hint">Toggle: P</div>
          </div>
          <pre id="perf-hud-text">—</pre>
        </div>
        <div id="compact-tabs" class="compact-tabs" aria-label="Panel shortcuts">
          <button class="btn" data-tab="general" type="button" title="General" aria-label="General">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 10.5L12 3l9 7.5" />
                <path d="M5 10v10h14V10" />
                <path d="M9 20v-6h6v6" />
              </svg>
            </span>
            <span class="sr-only">General</span>
          </button>
          <button class="btn" data-tab="layers" type="button" title="Layers" aria-label="Layers">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 3l9 5-9 5-9-5 9-5z" />
                <path d="M3 12l9 5 9-5" />
                <path d="M3 16.5l9 5 9-5" />
              </svg>
            </span>
            <span class="sr-only">Layers</span>
          </button>
          <button class="btn" data-tab="feeds" type="button" title="Feeds" aria-label="Feeds">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 4v16" />
                <path d="M4 8c4-4 8 4 16-2v10c-8 6-12-2-16 2" />
              </svg>
            </span>
            <span class="sr-only">Feeds</span>
          </button>
          <button class="btn" data-tab="catalog" type="button" title="Catalog" aria-label="Catalog">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 19V6a2 2 0 0 1 2-2h12v17" />
                <path d="M6 4v16" />
                <path d="M18 21H6a2 2 0 0 1-2-2" />
              </svg>
            </span>
            <span class="sr-only">Catalog</span>
          </button>
          <button class="btn" data-tab="settings" type="button" title="Settings" aria-label="Settings">
            <span class="icon" aria-hidden="true">
              <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 15.5a3.5 3.5 0 1 0 0-7 3.5 3.5 0 0 0 0 7z" />
                <path d="M19.4 15a7.8 7.8 0 0 0 .1-1 7.8 7.8 0 0 0-.1-1l2-1.6-2-3.4-2.4 1a8.4 8.4 0 0 0-1.7-1l-.4-2.6H9.1L8.7 7a8.4 8.4 0 0 0-1.7 1l-2.4-1-2 3.4L4.6 13a7.8 7.8 0 0 0-.1 1 7.8 7.8 0 0 0 .1 1l-2 1.6 2 3.4 2.4-1a8.4 8.4 0 0 0 1.7 1l.4 2.6h5.8l.4-2.6a8.4 8.4 0 0 0 1.7-1l2.4 1 2-3.4-2-1.6z" />
              </svg>
            </span>
            <span class="sr-only">Settings</span>
          </button>
        </div>
        <div id="map-controls" class="map-controls" data-pos="right" aria-label="Map controls">
          <button id="map-view" class="btn small" type="button" title="Toggle 2D/3D view">3D</button>
          <button id="map-compass" class="btn" type="button" title="North/South orientation">
            <span id="compass-needle" aria-hidden="true"></span>
            <span class="compass-label" aria-hidden="true">N</span>
          </button>
          <button id="map-home" class="btn" type="button" title="Reset camera (R)">⌂</button>
          <button id="map-zoom-in" class="btn" type="button" title="Zoom in">+</button>
          <button id="map-zoom-out" class="btn" type="button" title="Zoom out">−</button>
          <button id="map-mode" class="btn small" type="button" title="Lock drag mode">Auto</button>
          <button id="map-graticule" class="btn small" type="button" title="Toggle graticule">Grid</button>
          <button id="map-sun" class="btn small" type="button" title="Toggle real-time sun">Sun</button>
          <button id="map-help" class="btn small" type="button" title="About Atlas">?</button>
        </div>
      </div>

      <!-- Feed setup modal (glassy) -->
      <div id="feed-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="Add data feed">
        <div class="modal">
          <div class="modal-header">
            <h3>Add online feed</h3>
            <button id="feed-modal-close" type="button" class="btn" title="Close">✕</button>
          </div>

          <div class="grid">
            <div>
              <label for="feed-name">Name</label>
              <input id="feed-name" type="text" placeholder="e.g. GDACS Alerts" />
            </div>
            <div>
              <label for="feed-url">URL</label>
              <input id="feed-url" type="url" placeholder="https://…" />
              <div class="muted" style="font-size:12px; line-height:1.35; margin-top:6px;">
                Downloads are performed by the Atlas backend. If the backend is offline, adding/testing feeds is disabled.
              </div>
            </div>
            <div class="row" style="gap:10px;">
              <div style="flex:1;">
                <label for="feed-format">Format</label>
                <select id="feed-format">
                  <option value="auto" selected>Auto-detect</option>
                  <option value="csv">CSV</option>
                  <option value="json">JSON</option>
                  <option value="rss">RSS / XML</option>
                </select>
              </div>
              <div style="flex:1;">
                <label for="feed-max-rows">Max rows</label>
                <input id="feed-max-rows" type="number" min="1" max="50000" step="1" value="5000" />
              </div>
            </div>

            <div class="row" style="gap:10px; align-items:flex-end;">
              <div style="flex:1;">
                <label for="feed-csv-skip-rows">CSV: skip first rows</label>
                <input id="feed-csv-skip-rows" type="number" min="0" max="10000" step="1" value="0" />
              </div>
              <label class="checkbox" style="flex:1; margin:0;">
                <input id="feed-csv-header" type="checkbox" checked />
                <span>CSV: first row is header</span>
              </label>
            </div>

            <div>
              <label for="feed-csv-skip">CSV: skip row numbers (optional)</label>
              <input id="feed-csv-skip" type="text" placeholder="e.g. 2,5,10-12 (1=first non-empty row)" />
              <div class="muted" style="font-size:12px; line-height:1.35; margin-top:6px;">
                Uses 1-based row numbers after removing empty lines. Example: <span class="pill">2</span> skips the second row (often HDX metadata).
              </div>
            </div>

            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
              <div>
                <label for="feed-lat">Latitude field</label>
                <input id="feed-lat" type="text" placeholder="auto (e.g. lat, latitude, y)" />
              </div>
              <div>
                <label for="feed-lon">Longitude field</label>
                <input id="feed-lon" type="text" placeholder="auto (e.g. lon, longitude, x)" />
              </div>
            </div>

            <div>
              <label for="feed-filter">Filter (optional)</label>
              <input id="feed-filter" type="text" placeholder="e.g. country contains 'Kenya'" />
              <div class="muted" style="font-size:12px; line-height:1.35; margin-top:6px;">
                Simple filter syntax: <span class="pill">field contains value</span> (case-insensitive).
              </div>
            </div>

            <div id="feed-preview" class="muted" style="font-size:12px; line-height:1.35;">
              Preview will appear after you click “Test download”.
            </div>
          </div>

          <div class="modal-footer">
            <button id="feed-test-btn" type="button" class="btn">Test download</button>
            <button id="feed-save-btn" type="button">Save</button>
          </div>
        </div>
      </div>

      <!-- About modal -->
      <div id="about-modal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-label="About Atlas">
        <div class="modal" style="max-width: 480px;">
          <div class="modal-header">
            <h3>About Atlas</h3>
            <button id="about-modal-close" type="button" class="btn" title="Close">✕</button>
          </div>

          <div class="grid" style="gap: 14px;">
            <p style="margin: 0; line-height: 1.5;">
              <strong>Atlas</strong> is a high-performance geospatial visualization engine built with 
              Rust and WebGPU. It renders 2D maps and 3D globes with real-time data overlays.
            </p>

            <div>
              <h4 style="margin: 0 0 8px 0; font-size: 14px;">Features</h4>
              <ul style="margin: 0; padding-left: 20px; line-height: 1.6;">
                <li>3D globe with smooth arcball navigation</li>
                <li>2D Mercator map view</li>
                <li>Real-time data feeds (CSV, JSON, RSS)</li>
                <li>GeoJSON file upload support</li>
                <li>Time-enabled playback controls</li>
                <li>Layer filtering and search</li>
                <li>Real-time sun positioning</li>
                <li>Multiple color themes</li>
              </ul>
            </div>

            <div>
              <h4 style="margin: 0 0 8px 0; font-size: 14px;">Controls</h4>
              <div style="font-size: 13px; line-height: 1.6;">
                <strong>3D Mode:</strong> Drag to orbit • Right-click/Shift+drag to pan<br/>
                <strong>2D Mode:</strong> Drag to pan<br/>
                <strong>Zoom:</strong> Scroll wheel or pinch<br/>
                <strong>Reset:</strong> Press R key
              </div>
            </div>

            <div class="muted" style="font-size: 12px; text-align: center; padding-top: 8px; border-top: 1px solid var(--controls-border);">
              Built with Rust, WebGPU & WebAssembly
            </div>
          </div>

          <div class="modal-footer">
            <button id="about-modal-ok" type="button">OK</button>
          </div>
        </div>
      </div>
    </div>
    <script type="module">
      // Global view mode state (initialized early so status functions can read it).
      let viewMode = "3d";
      try {
        const saved = (localStorage.getItem("atlas.viewMode") || "3d").toLowerCase();
        viewMode = (saved === "2d" || saved === "3d") ? saved : "3d";
      } catch (_) {}

      // File upload size limit in bytes (default 1GB, max 1GB).
      const MAX_UPLOAD_SIZE_MB_LIMIT = 1024;
      const DEFAULT_UPLOAD_SIZE_MB = 1024;
      let uploadSizeLimitMB = DEFAULT_UPLOAD_SIZE_MB;
      try {
        const saved = parseInt(localStorage.getItem("atlas.uploadSizeMB") || "", 10);
        if (Number.isFinite(saved) && saved >= 1 && saved <= MAX_UPLOAD_SIZE_MB_LIMIT) {
          uploadSizeLimitMB = saved;
        }
      } catch (_) {}

      // Max coordinate pairs for GeoJSON uploads (default 10M, max 10M).
      const MAX_COORD_PAIRS_LIMIT = 10_000_000;
      const DEFAULT_MAX_COORD_PAIRS = 10_000_000;
      let maxCoordPairs = DEFAULT_MAX_COORD_PAIRS;
      try {
        const saved = parseInt(localStorage.getItem("atlas.maxCoordPairs") || "", 10);
        if (Number.isFinite(saved) && saved >= 100_000 && saved <= MAX_COORD_PAIRS_LIMIT) {
          maxCoordPairs = saved;
        }
      } catch (_) {}

      function normalizeTheme(theme) {
        const t = String(theme || "").trim().toLowerCase();
        if (t === "deep-dark" || t === "deep" || t === "black") return "deep-dark";
        if (t === "light" || t === "day") return "light";
        return "dark";
      }

      function getInitialTheme() {
        try {
          const saved = String(localStorage.getItem("atlas-theme") || "").trim();
          if (saved) return normalizeTheme(saved);
        } catch (_) {
          // ignore
        }
        const prefersLight = window.matchMedia && window.matchMedia("(prefers-color-scheme: light)").matches;
        return prefersLight ? "light" : "dark";
      }

      function applyTheme(theme, wasm) {
        const t = normalizeTheme(theme);
        document.documentElement.dataset.theme = t;
        try { localStorage.setItem("atlas-theme", t); } catch (_) {}
        try { wasm?.set_theme?.(t); } catch (err) { console.error("set_theme failed", err); }
        return t;
      }

      async function gunzipIfNeeded(bytes) {
        if (!bytes || bytes.length < 2) return bytes;
        if (bytes[0] !== 0x1f || bytes[1] !== 0x8b) return bytes;

        // Modern browsers: native gzip decompression.
        if (typeof DecompressionStream !== "undefined") {
          const ds = new DecompressionStream("gzip");
          const stream = new Blob([bytes]).stream().pipeThrough(ds);
          const ab = await new Response(stream).arrayBuffer();
          return new Uint8Array(ab);
        }

        // Fallback: dynamically load pako.
        const pako = await import("https://esm.sh/pako@2.1.0");
        return pako.ungzip(bytes);
      }

      async function tryLoadPmtilesBaseSurface(wasm) {
        // Feature flag (optional): set `window.ATLAS_USE_PMTILES_SURFACE = false` to disable.
        if (window.ATLAS_USE_PMTILES_SURFACE === false) return false;

        // Debugging must survive reloads; window globals do not.
        // Enable via either:
        //  - URL: http://localhost:9103/?pmtiles_debug=1
        //  - DevTools: localStorage.setItem('atlas-pmtiles-debug','true')
        const debug = (() => {
          try {
            if (window.ATLAS_PMTILES_DEBUG === true) return true;
          } catch (_) {}
          try {
            const q = new URLSearchParams(location.search);
            if (q.get("pmtiles_debug") === "1" || q.get("pmtiles_debug") === "true") return true;
          } catch (_) {}
          try {
            return localStorage.getItem("atlas-pmtiles-debug") === "true";
          } catch (_) {}
          return false;
        })();

        const url = "assets/world.pmtiles";
        try {
          // Load libs on demand.
          const pm = await import("https://esm.sh/pmtiles@3.2.0");
          const vt = await import("https://esm.sh/@mapbox/vector-tile@1.3.1");
          const PbfMod = await import("https://esm.sh/pbf@3.2.1");
          const Pbf = PbfMod.default;
          const { PMTiles, FetchSource } = pm;
          const { VectorTile } = vt;

          // Build a PMTiles reader that uses HTTP range requests.
          const p = new PMTiles(new FetchSource(url));

          // Confirm archive is readable.
          const header = await p.getHeader();
          const maxZoomAvailable = Number.isFinite(header?.maxZoom) ? header.maxZoom : 0;

          // Read metadata for easier layer discovery.
          let metadata = null;
          try {
            metadata = await p.getMetadata();
          } catch (_) {
            metadata = null;
          }

          if (debug) {
            console.log("PMTiles header", header);
            console.log("PMTiles metadata keys", metadata ? Object.keys(metadata) : null);
            console.log(
              "PMTiles vector_layers",
              metadata?.vector_layers ? metadata.vector_layers.map((vl) => vl?.id).filter(Boolean) : null,
            );
          }

          // Limit global refinement to avoid hammering the browser with requests.
          // You can override via `window.ATLAS_PMTILES_MAX_ZOOM`.
          // Default: scan up to the archive's max zoom (this asset is small: max z=5).
          const maxZoom = Math.max(0, Math.min(maxZoomAvailable, Number(window.ATLAS_PMTILES_MAX_ZOOM ?? maxZoomAvailable)));

          // Requested layer name (optional). If wrong, we auto-detect a polygon layer.
          const requestedLayerId = String(window.ATLAS_PMTILES_LAYER_ID || "ne_10m_land");
          let resolvedLayerId = requestedLayerId;
          let resolvedLayerLocked = false;

          // If metadata says the requested layer doesn't exist, pick the first vector layer.
          try {
            const metaLayers = metadata?.vector_layers ? metadata.vector_layers.map((vl) => vl?.id).filter(Boolean) : [];
            if (metaLayers.length && !metaLayers.includes(resolvedLayerId)) {
              resolvedLayerId = metaLayers[0];
              resolvedLayerLocked = true;
            }
          } catch (_) {
            // ignore
          }

          if (!wasm?.begin_base_world_stream || !wasm?.append_base_world_geojson_chunk || !wasm?.finish_base_world_stream) {
            console.warn("PMTiles base surface: missing wasm streaming APIs; falling back to world.json");
            return false;
          }

          wasm.begin_base_world_stream();

          const maxFeaturesPerTile = Number(window.ATLAS_PMTILES_MAX_FEATURES_PER_TILE ?? 2000);
          const concurrency = Math.max(
            1,
            Math.min(8, Number(window.ATLAS_PMTILES_CONCURRENCY ?? Math.min(6, navigator?.hardwareConcurrency ?? 4))),
          );
          const batchMaxTiles = Math.max(1, Math.min(128, Number(window.ATLAS_PMTILES_BATCH_MAX_TILES ?? 24)));
          const batchMaxFeatures = Math.max(100, Math.min(200000, Number(window.ATLAS_PMTILES_BATCH_MAX_FEATURES ?? 20000)));
          const flushIntervalMs = Math.max(100, Math.min(5000, Number(window.ATLAS_PMTILES_FLUSH_INTERVAL_MS ?? 500)));
          const yieldBudgetMs = Math.max(4, Math.min(25, Number(window.ATLAS_PMTILES_YIELD_BUDGET_MS ?? 10)));
          const userIdleMs = Math.max(50, Math.min(2000, Number(window.ATLAS_PMTILES_USER_IDLE_MS ?? 250)));

          const nextFrame = () => new Promise((r) => requestAnimationFrame(() => r()));
          const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
          const nowMs = () => (performance?.now ? performance.now() : Date.now());
          const lastInputMs = () => {
            try {
              const v = Number(window.__atlasLastInputMs);
              return Number.isFinite(v) ? v : -Infinity;
            } catch (_) {
              return -Infinity;
            }
          };
          const isUserInteracting = () => nowMs() - lastInputMs() < userIdleMs;
          async function waitForUserIdle() {
            // Back off aggressively while the user is manipulating the globe.
            while (isUserInteracting()) {
              await sleep(50);
            }
          }

          let appendedTilesWithFeatures = 0;
          let appendedPolygonFeatures = 0;
          let tilesMissingData = 0;
          let tilesEmptyBytes = 0;
          let tilesParsedButNoLayer = 0;
          let tilesWithLayerButNoPolys = 0;

          // Batch many tiles into a single GeoJSON chunk to reduce JSON parsing and wasm calls.
          let pendingFeatures = [];
          let pendingTiles = 0;
          let lastFlushMs = 0;

          function flushPendingFeatures(force) {
            if (!pendingFeatures.length) return;
            const now = performance.now();
            if (!force && now - lastFlushMs < flushIntervalMs) return;
            lastFlushMs = now;

            // Avoid doing heavy wasm work while the user is interacting.
            // Note: this is sync, so we only gate on a cheap check here.
            if (!force) {
              try {
                if (isUserInteracting()) return;
              } catch (_) {}
            }

            const fc = { type: "FeatureCollection", features: pendingFeatures };
            wasm.append_base_world_geojson_chunk(JSON.stringify(fc));
            pendingFeatures = [];
            pendingTiles = 0;
            // NOTE: We no longer call finish_base_world_stream() here to avoid
            // expensive triangulation + GPU upload on every batch. The final
            // call happens once at the end of the entire PMTiles load.
          }

          function tryResolvePolygonLayer(tile) {
            if (resolvedLayerLocked) return;
            const layers = tile?.layers || {};
            for (const key of Object.keys(layers)) {
              const layer = layers[key];
              if (!layer || !layer.length) continue;
              const n = Math.min(layer.length, 100);
              for (let i = 0; i < n; i++) {
                try {
                  const f = layer.feature(i);
                  if (f && f.type === 3) {
                    resolvedLayerId = key;
                    resolvedLayerLocked = true;
                    return;
                  }
                } catch (_) {
                  // ignore
                }
              }
            }
          }

          async function loadTile(z, x, y) {
            const resp = await p.getZxy(z, x, y);
            // pmtiles returns `undefined` when the tile doesn't exist.
            if (!resp || !resp.data) {
              tilesMissingData++;
              if (debug && z <= 1 && x === 0 && y === 0) {
                console.log(`PMTiles debug: getZxy(${z},${x},${y}) returned null`);
              }
              return null;
            }
            // Normalize to Uint8Array.
            let bytes = resp.data instanceof Uint8Array ? resp.data : new Uint8Array(resp.data);

            if (debug && z === 0 && x === 0 && y === 0) {
              let ctor = "unknown";
              try { ctor = resp?.data?.constructor?.name ?? ctor; } catch (_) {}
              console.log("PMTiles debug: z0 getZxy type", {
                ctor,
                byteLength: resp?.data?.byteLength,
                length: resp?.data?.length,
              });

              const b0 = bytes[0];
              const b1 = bytes[1];
              const b2 = bytes[2];
              const b3 = bytes[3];
              console.log("PMTiles debug: z0 raw bytes", { len: bytes.length, b0, b1, b2, b3 });
            }

            if (bytes.length === 0) {
              tilesEmptyBytes++;
              return null;
            }

            bytes = await gunzipIfNeeded(bytes);
            const tile = new VectorTile(new Pbf(bytes));

            if (debug && z === 0 && x === 0 && y === 0) {
              console.log("PMTiles debug: z0 tile layer keys", tile?.layers ? Object.keys(tile.layers) : null);
            }

            // If the requested layer doesn't exist, auto-detect a polygon layer from the first usable tile.
            if (!tile.layers?.[resolvedLayerId]) {
              tryResolvePolygonLayer(tile);
            }

            const layer = tile.layers?.[resolvedLayerId];
            if (!layer || !layer.length) {
              tilesParsedButNoLayer++;
              return null;
            }

            const features = [];
            const n = Math.min(layer.length, maxFeaturesPerTile);
            for (let i = 0; i < n; i++) {
              const f = layer.feature(i);
              // 3 = polygon in MVT
              if (f.type !== 3) continue;
              const gj = f.toGeoJSON(x, y, z);
              // Reduce payload: drop properties
              features.push({ type: "Feature", properties: {}, geometry: gj.geometry });
            }
            if (!features.length) {
              tilesWithLayerButNoPolys++;
              return null;
            }
            return { type: "FeatureCollection", features };
          }

          async function loadZoom(z) {
            const n = 1 << z;
            const tileCount = n * n;
            let loadedTiles = 0;
            let idx = 0;

            const schedule = async (z, x, y) => {
              const fc = await loadTile(z, x, y);
              if (fc) {
                // Merge tile features into a batched FeatureCollection.
                pendingFeatures.push(...fc.features);
                pendingTiles++;
                appendedTilesWithFeatures++;
                appendedPolygonFeatures += fc.features.length;

                if (pendingTiles >= batchMaxTiles || pendingFeatures.length >= batchMaxFeatures) {
                  flushPendingFeatures(false);
                }
              }
              loadedTiles++;
            };

            async function worker(workerId) {
              let lastYield = performance.now();
              while (true) {
                const i = idx++;
                if (i >= tileCount) break;

                // If the user is interacting, pause tile IO/decoding.
                if (isUserInteracting()) {
                  flushPendingFeatures(false);
                  await waitForUserIdle();
                }

                const x = i % n;
                const y = (i / n) | 0;
                await schedule(z, x, y);
                // Keep the main thread responsive.
                const now = performance.now();
                if (now - lastYield > yieldBudgetMs) {
                  lastYield = now;
                  flushPendingFeatures(false);
                  await nextFrame();
                }
              }
            }

            await Promise.all(Array.from({ length: concurrency }, (_, i) => worker(i)));
            // Zoom boundary: flush whatever we have so refinement becomes visible.
            flushPendingFeatures(true);
            return loadedTiles;
          }

          // Progressive refinement. Some archives omit meaningful data at low zooms.
          // If the user configured a low max zoom, auto-extend up to the archive max zoom
          // before falling back.
          let maxZoomUsed = maxZoom;
          for (let z = 0; z <= maxZoomUsed; z++) {
            await loadZoom(z);
            // Yield between zoom levels to keep orbit/pan snappy.
            await nextFrame();
          }

          if (appendedPolygonFeatures === 0 && maxZoomUsed < maxZoomAvailable) {
            if (debug) {
              console.log(
                `PMTiles debug: no polygons at z0..z${maxZoomUsed}; extending scan to z${maxZoomAvailable}`,
              );
            }
            for (let z = maxZoomUsed + 1; z <= maxZoomAvailable; z++) {
              maxZoomUsed = z;
              await loadZoom(z);
              await nextFrame();
            }
          }

          // Final flush.
          await waitForUserIdle();
          flushPendingFeatures(true);

          // Finalize once so Rust triangulates and uploads.
          // (Without this, `base_polygons` stays 0 and we incorrectly fall back.)
          try {
            wasm.finish_base_world_stream?.();
          } catch (e) {
            console.warn("finish_base_world_stream failed", e);
          }

          if (appendedPolygonFeatures === 0) {
            console.warn(
              `PMTiles base surface: no polygons decoded (requested layer=${requestedLayerId}, resolved=${resolvedLayerId}); falling back to world.json` +
                ` (tilesMissingData=${tilesMissingData}, tilesEmptyBytes=${tilesEmptyBytes}, tilesParsedButNoLayer=${tilesParsedButNoLayer}, tilesWithLayerButNoPolys=${tilesWithLayerButNoPolys}, maxZoom=${maxZoomUsed})`,
            );
            return false;
          }

          // Verify the WASM side actually produced triangles (earcut can fail on invalid rings).
          try {
            const st = wasm.get_surface_status?.();
            const basePolys = Number(st?.base_polygons ?? 0);
            if (!Number.isFinite(basePolys) || basePolys <= 0) {
              console.warn(
                `PMTiles base surface: decoded polygons but produced 0 triangles (requested layer=${requestedLayerId}, resolved=${resolvedLayerId}); falling back to world.json`,
              );
              return false;
            }
          } catch (e) {
            // If status is unavailable, don't block.
          }

          console.log(
            `PMTiles base surface loaded (z0..z${maxZoomUsed}, layer=${resolvedLayerId}, requested=${requestedLayerId}, polygons=${appendedPolygonFeatures}, tiles_with_features=${appendedTilesWithFeatures})`,
          );
          return true;
        } catch (err) {
          console.warn("PMTiles base surface load failed; falling back to world.json", err);
          try { wasm.finish_base_world_stream?.(); } catch (_) {}
          return false;
        }
      }

      function getPmtilesSurfacePrefs() {
        // Prefer stable world.json fallback by default.
        let enabled = false;
        // Default to z5 because the bundled world.pmtiles only goes to z5 and some archives
        // omit meaningful data at very low zooms.
        let maxZoom = 5;
        try {
          const v = localStorage.getItem("atlas-surface-pmtiles-enabled");
          if (v === "false") enabled = false;
          if (v === "true") enabled = true;
        } catch (_) {}
        try {
          const z = Number(localStorage.getItem("atlas-surface-pmtiles-max-zoom"));
          if (Number.isFinite(z)) maxZoom = Math.max(0, Math.min(5, Math.floor(z)));
        } catch (_) {}
        return { enabled, maxZoom };
      }

      function setPmtilesSurfacePrefs(enabled, maxZoom) {
        try { localStorage.setItem("atlas-surface-pmtiles-enabled", enabled ? "true" : "false"); } catch (_) {}
        try { localStorage.setItem("atlas-surface-pmtiles-max-zoom", String(maxZoom)); } catch (_) {}
      }

      function applyPmtilesSurfacePrefsToGlobals(prefs) {
        window.ATLAS_USE_PMTILES_SURFACE = !!prefs.enabled;
        window.ATLAS_PMTILES_MAX_ZOOM = prefs.maxZoom;
      }

      async function reloadBaseSurface(wasm) {
        // Deterministic policy:
        // - If backend is online, prefer server surface tiles (wasm will load them).
        // - If backend is offline, fall back to a bundled base-world (world.json by default).
        try {
          if (window.__atlasBackendUrl) return;
        } catch (_) {}

        const prefs = getPmtilesSurfacePrefs();
        applyPmtilesSurfacePrefsToGlobals(prefs);
        if (prefs.enabled) {
          const ok = await tryLoadPmtilesBaseSurface(wasm);
          if (ok) return;
        }
        try { wasm.load_base_world?.(); } catch (err) { console.error("load_base_world failed", err); }
      }

      function wireSurfacePrefs(wasm) {
        const cb = document.getElementById("surface-use-pmtiles");
        const slider = document.getElementById("surface-pmtiles-max-zoom");
        const value = document.getElementById("surface-pmtiles-max-zoom-value");
        if (!cb || !slider || !value) return;

        const prefs = getPmtilesSurfacePrefs();
        cb.checked = !!prefs.enabled;
        slider.value = String(prefs.maxZoom);
        value.textContent = String(prefs.maxZoom);

        const apply = async () => {
          const enabled = !!cb.checked;
          const maxZoom = Math.max(0, Math.min(5, Math.floor(Number(slider.value) || 0)));
          slider.value = String(maxZoom);
          value.textContent = String(maxZoom);
          setPmtilesSurfacePrefs(enabled, maxZoom);
          await reloadBaseSurface(wasm);
        };

        cb.addEventListener("change", () => {
          apply().catch((e) => console.warn("surface apply failed", e));
        });
        slider.addEventListener("input", () => {
          const maxZoom = Math.max(0, Math.min(5, Math.floor(Number(slider.value) || 0)));
          value.textContent = String(maxZoom);
        });
        slider.addEventListener("change", () => {
          apply().catch((e) => console.warn("surface apply failed", e));
        });
      }

      async function main(wasm) {
        // Apply theme early so both UI and renderer pick consistent defaults.
        const theme = applyTheme(getInitialTheme(), wasm);
        wireUi(wasm);
        wireSurfacePrefs(wasm);
        resizeCanvas(wasm);
        window.addEventListener("resize", () => {
          resizeCanvas(wasm);
          if (isCompactLayout()) {
            document.getElementById("side-panel")?.classList.remove("compact-open");
          }
        });
        // Do not block startup on backend health checks: when the backend is offline,
        // connection attempts can take a long time to fail. We want the renderer to
        // initialize immediately so the globe (and any bundled fallback) can draw.
        const backendOkPromise = detectBackendAvailability(wasm);

        wasm.init_canvas_2d();
        wasm.init_wgpu();
        startSurfaceStatusPolling(wasm);
        start2DPerfPolling(wasm);
        wirePerfHudUi(wasm);
        startPerfHudPolling(wasm);
        startTerrainClientStatusPolling(wasm);
        startAnimation(wasm);
        wireTimeDial(wasm);

        // If the backend is offline, kick the base surface loader (PMTiles/world.json).
        backendOkPromise
          .then((ok) => {
            if (!ok) {
              // UI hint: world.json can take a moment to fetch/parse.
              setSurfaceStatus("Surface: loading base world (offline)…");
              return reloadBaseSurface(wasm);
            }
          })
          .catch((e) => console.warn("backend detection failed", e));
      }

      async function fetchWithTimeout(url, options, timeoutMs) {
        const controller = new AbortController();
        const id = window.setTimeout(() => controller.abort(), timeoutMs);
        try {
          return await fetch(url, { ...(options || {}), signal: controller.signal });
        } finally {
          window.clearTimeout(id);
        }
      }

      function getTerrainPreference() {
        try {
          const v = String(localStorage.getItem("atlas-terrain-enabled") || "").trim().toLowerCase();
          if (v === "true") return true;
          if (v === "false") return false;
        } catch (_) {
          // ignore
        }
        return null;
      }

      function setTerrainPreference(enabled) {
        try {
          localStorage.setItem("atlas-terrain-enabled", enabled ? "true" : "false");
        } catch (_) {
          // ignore
        }
      }

      async function detectBackendAvailability(wasm) {
        const notify = () => {
          try { window.dispatchEvent(new Event("atlas-backend-change")); } catch (_) {}
        };

        // If the browser already knows we're offline, don't waste time probing.
        try {
          if (typeof navigator !== "undefined" && navigator && navigator.onLine === false) {
            window.__atlasBackendUrl = "";
            window.__atlasStacUrl = "https://copernicus-dem-30m-stac.s3.amazonaws.com";
            setStatus("Backend: offline (using defaults)");
            setDemStatus("Terrain (backend): offline");
            notify();
            return false;
          }
        } catch (_) {}

        const override = window.ATLAS_BACKEND_URL || "";
        const host = window.location.hostname || "localhost";
        const scheme = window.location.protocol === "https:" ? "https" : "http";
        const fallbackDocker = `${scheme}://${host}:9102`;
        const fallbackLocal = `${scheme}://${host}:9100`;
        const candidates = [
          String(override || "").trim(),
          fallbackDocker,
          fallbackLocal,
        ].filter(Boolean);

        for (const base of candidates) {
          try {
            // Keep this tight: if the backend is down, we want to proceed quickly.
            const resp = await fetchWithTimeout(`${base}/healthz`, { method: "GET" }, 900);
            if (resp.ok) {
              window.__atlasBackendUrl = base;
              window.__atlasStacUrl = `${base}/stac`;
              setStatus(`Backend: connected (${base})`);
              startTerrainStatusPolling(base);

              // If a backend is available, enable streaming terrain by default.
              // Persist the choice so users can opt out.
              const pref = getTerrainPreference();
              const shouldEnableTerrain = pref === null ? true : !!pref;
              if (pref === null) setTerrainPreference(true);

              if (shouldEnableTerrain) {
                try { wasm?.set_layer_visible?.("terrain", true); } catch (err) { console.error("enable terrain failed", err); }
                const cb = document.getElementById("layer-terrain");
                if (cb) cb.checked = true;
              }
              notify();
              return true;
            }
          } catch (err) {
            // ignore and try next
          }
        }

        window.__atlasBackendUrl = "";
        window.__atlasStacUrl = "https://copernicus-dem-30m-stac.s3.amazonaws.com";
        setStatus("Backend: offline (using defaults)");
        setDemStatus("Terrain (backend): offline");
        notify();
        return false;
      }

      function startAnimation(wasm) {
        let fpsFrames = 0;
        let fpsLastT = performance.now();
        window.__atlasFps = 0;
        function loop() {
          // If the tab is hidden, avoid burning CPU/GPU.
          // We still keep the RAF alive so we resume immediately when visible.
          if (document.hidden) {
            window.requestAnimationFrame(loop);
            return;
          }

          // Best-effort FPS meter based on the RAF loop.
          fpsFrames += 1;
          const now = performance.now();
          if (now - fpsLastT >= 1000) {
            window.__atlasFps = Math.round((fpsFrames * 1000) / Math.max(1, now - fpsLastT));
            fpsFrames = 0;
            fpsLastT = now;
          }

          try {
            wasm.advance_frame();
          } catch (e) {
            console.error("advance_frame failed", e);
            return;
          }
          window.requestAnimationFrame(loop);
        }
        window.requestAnimationFrame(loop);
      }

      function getPerfHudPreference() {
        try {
          const v = String(localStorage.getItem("atlas-perf-hud") || "").trim().toLowerCase();
          if (v === "true") return true;
          if (v === "false") return false;
        } catch (_) {
          // ignore
        }
        return false;
      }

      function setPerfHudPreference(enabled) {
        try {
          localStorage.setItem("atlas-perf-hud", enabled ? "true" : "false");
        } catch (_) {
          // ignore
        }
      }

      function setPerfHudVisible(visible) {
        const hud = document.getElementById("perf-hud");
        if (hud) hud.classList.toggle("hidden", !visible);
        const cb = document.getElementById("toggle-perf-hud");
        if (cb) cb.checked = !!visible;
      }

      function wirePerfHudUi(_wasm) {
        const initial = getPerfHudPreference();
        setPerfHudVisible(initial);

        const cb = document.getElementById("toggle-perf-hud");
        if (cb) {
          cb.checked = initial;
          cb.addEventListener("change", () => {
            const enabled = !!cb.checked;
            setPerfHudPreference(enabled);
            setPerfHudVisible(enabled);
          });
        }

        window.addEventListener("keydown", (e) => {
          // Avoid typing into inputs.
          const t = e?.target;
          const tag = t && t.tagName ? String(t.tagName).toLowerCase() : "";
          if (tag === "input" || tag === "textarea" || tag === "select") return;

          if (e.key === "p" || e.key === "P") {
            const next = !getPerfHudPreference();
            setPerfHudPreference(next);
            setPerfHudVisible(next);
          }
        });
      }

      function startPerfHudPolling(wasm) {
        function fmtBytes(n) {
          const x = Number(n || 0);
          if (!Number.isFinite(x) || x <= 0) return "0 B";
          if (x < 1024) return `${Math.round(x)} B`;
          if (x < 1024 * 1024) return `${(x / 1024).toFixed(1)} KiB`;
          if (x < 1024 * 1024 * 1024) return `${(x / (1024 * 1024)).toFixed(2)} MiB`;
          return `${(x / (1024 * 1024 * 1024)).toFixed(2)} GiB`;
        }

        function poll() {
          if (document.hidden) return;
          if (!getPerfHudPreference()) return;
          const out = document.getElementById("perf-hud-text");
          if (!out) return;

          let lines = [];
          try {
            const fps = Math.round(Number(window.__atlasFps || 0));
            lines.push(`${viewMode.toUpperCase()} • FPS ${fps}`);
          } catch (_) {
            // ignore
          }

          // WebGPU counters (both 2D+3D).
          try {
            if (wasm && wasm.get_gpu_perf_stats) {
              const g = wasm.get_gpu_perf_stats();
              const frameMs = Number(g.frame_ms || 0).toFixed(2);
              const uploads = Math.round(Number(g.upload_calls || 0));
              const bytes = Math.round(Number(g.upload_bytes || 0));
              const mibps = Number(g.upload_mib_per_s || 0).toFixed(1);
              const passes = Math.round(Number(g.render_passes || 0));
              const draws = Math.round(Number(g.draw_calls || 0));
              const inst = Math.round(Number(g.draw_instances || 0));
              const vtx = Math.round(Number(g.draw_vertices || 0));
              const idx = Math.round(Number(g.draw_indices || 0));
              lines.push(
                `GPU frame ${frameMs}ms • passes ${passes} • draws ${draws}`
              );
              lines.push(
                `GPU uploads ${uploads} • ${fmtBytes(bytes)} • ${mibps} MiB/s`
              );
              lines.push(
                `GPU verts ${vtx} • idx ${idx} • inst ${inst}`
              );
            }
          } catch (_) {
            // ignore
          }

          // 2D CPU timings (only meaningful in 2D mode, but safe to show).
          try {
            if (wasm && wasm.get_2d_perf_stats && viewMode === "2d") {
              const s = wasm.get_2d_perf_stats();
              const total = Number(s.total_ms || 0).toFixed(1);
              const poly = Number(s.poly_ms || 0).toFixed(1);
              const line = Number(s.line_ms || 0).toFixed(1);
              const pt = Number(s.point_ms || 0).toFixed(1);
              const tris = Math.round(Number(s.poly_tris || 0));
              const segs = Math.round(Number(s.line_segs || 0));
              const pts = Math.round(Number(s.points || 0));
              lines.push(
                `2D CPU ${total}ms • poly ${poly}ms/${tris} tri • line ${line}ms/${segs} seg • pt ${pt}ms/${pts}`
              );
            }
          } catch (_) {
            // ignore
          }

          out.textContent = lines.join("\n") || "—";
        }

        poll();
        window.setInterval(poll, 500);
      }

      function start2DPerfPolling(wasm) {
        function poll() {
          if (document.hidden) return;
          try {
            if (viewMode !== "2d") return;
            if (!wasm.get_2d_perf_stats) return;
            const s = wasm.get_2d_perf_stats();
            if (!s) return;
            const total = Number(s.total_ms || 0).toFixed(1);
            const poly = Number(s.poly_ms || 0).toFixed(1);
            const line = Number(s.line_ms || 0).toFixed(1);
            const pt = Number(s.point_ms || 0).toFixed(1);
            const tris = Math.round(Number(s.poly_tris || 0));
            const segs = Math.round(Number(s.line_segs || 0));
            const pts = Math.round(Number(s.points || 0));
            setSurfacePerfStatus(
              `2D ${total}ms (poly ${poly}/${tris} tri • line ${line}/${segs} seg • pt ${pt}/${pts})`
            );
          } catch (_) {
            // ignore
          }
        }
        poll();
        window.setInterval(poll, 700);
      }

      function isCompactLayout() {
        return window.matchMedia("(max-width: 900px)").matches;
      }

      function resizeCanvas(wasm) {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const canvas2d = document.getElementById("atlas-canvas-2d");
        const canvas3d = document.getElementById("atlas-canvas-3d");
        canvas2d.width = width;
        canvas2d.height = height;
        canvas3d.width = width;
        canvas3d.height = height;
        wasm.set_canvas_sizes(width, height);
      }

      function setStatus(text) {
        const el = document.getElementById("status-text");
        if (!el) return;
        if (el.textContent === text) return;
        el.textContent = text;
      }

      function setDemStatus(text) {
        const el = document.getElementById("dem-status-text");
        if (!el) return;
        if (el.textContent === text) return;
        el.textContent = text;
      }

      let surfaceStatusBase = "";
      let surfaceStatusPerf = "";

      function updateSurfaceStatusDisplay() {
        const el = document.getElementById("surface-status-text");
        if (!el) return;
        const showPerf = viewMode === "2d" && !!surfaceStatusPerf;
        const text = showPerf ? `${surfaceStatusBase} • ${surfaceStatusPerf}` : surfaceStatusBase;
        if (el.textContent === text) return;
        el.textContent = text;
      }

      function setSurfaceStatus(text) {
        surfaceStatusBase = text;
        updateSurfaceStatusDisplay();
      }

      function setSurfacePerfStatus(text) {
        surfaceStatusPerf = text;
        updateSurfaceStatusDisplay();
      }

      function setTerrainClientStatus(text) {
        const el = document.getElementById("terrain-client-status-text");
        if (!el) return;
        if (el.textContent === text) return;
        el.textContent = text;
      }

      function startTerrainStatusPolling(baseUrl) {
        async function poll() {
          if (document.hidden) return;
          if (!baseUrl) {
            setDemStatus("Terrain (backend): offline");
            return;
          }
          try {
            const resp = await fetch(`${baseUrl}/terrain/status`, { method: "GET" });
            if (!resp.ok) {
              setDemStatus(`Terrain (backend): status unavailable (${resp.status})`);
              return;
            }
            const data = await resp.json();
            const tiles = Number.isFinite(data.tiles_count) ? data.tiles_count : 0;
            const suffix = data.tiles_count_truncated ? "+" : "";
            const datum = data.vertical_datum ? ` • ${String(data.vertical_datum)}` : "";
            if (data.status === "ready") {
              setDemStatus(`Terrain (backend): ready (${tiles}${suffix} cached${datum})`);
            } else if (data.status === "empty") {
              setDemStatus(`Terrain (backend): empty cache${datum}`);
            } else {
              setDemStatus(`Terrain (backend): ${String(data.status || "unknown")}${datum}`);
            }
          } catch (err) {
            setDemStatus("Terrain (backend): status error");
          }
        }

        poll();
        window.setInterval(poll, 10_000);
      }

      function startTerrainClientStatusPolling(wasm) {
        function poll() {
          if (document.hidden) return;
          try {
            if (!wasm.get_terrain_client_status) {
              setTerrainClientStatus("Terrain (client): unavailable");
              return;
            }
            const status = wasm.get_terrain_client_status();
            const enabled = !!status.enabled;
            const loading = !!status.loading;
            const zoom = status.zoom !== undefined ? ` z${status.zoom}` : "";
            const source = status.source ? ` @ ${status.source}` : "";
            const datum = status.vertical_datum ? ` • ${String(status.vertical_datum)}` : "";
            if (!enabled) {
              setTerrainClientStatus("Terrain (client): disabled");
              return;
            }
            if (loading) {
              setTerrainClientStatus(`Terrain (client): loading${zoom}${source}${datum}`);
              return;
            }
            if (status.last_error) {
              setTerrainClientStatus(`Terrain (client): error (${status.last_error})`);
              return;
            }
            if (status.tileset_loaded) {
              setTerrainClientStatus(`Terrain (client): ready${zoom}${source}${datum}`);
              return;
            }
            setTerrainClientStatus("Terrain (client): idle");
          } catch (err) {
            setTerrainClientStatus("Terrain (client): status error");
          }
        }

        poll();
        window.setInterval(poll, 3_000);
      }

      function startSurfaceStatusPolling(wasm) {
        function poll() {
          if (document.hidden) return;
          try {
            if (!wasm.get_surface_status) {
              setSurfaceStatus("Surface: unavailable");
              return;
            }
            const status = wasm.get_surface_status();
            const zoom = status.zoom !== undefined ? ` z${status.zoom}` : "";
            const source = status.source ? ` @ ${status.source}` : "";
            if (status.loading) {
              const src = String(status.source || "");
              const isWorldJson = src.includes("world.json");
              const isPmtiles = src.includes(".pmtiles");
              if (isWorldJson) {
                setSurfaceStatus("Surface: loading base world (world.json)…");
              } else if (isPmtiles) {
                setSurfaceStatus(`Surface: loading base world (PMTiles)…${zoom}${source}`);
              } else {
                setSurfaceStatus(`Surface: loading${zoom}${source}`);
              }
              return;
            }
            if (status.error) {
              setSurfaceStatus(`Surface: error (${status.error})`);
              return;
            }
            if (status.tileset_loaded) {
              setSurfaceStatus(`Surface: tiles ready${zoom}${source}`);
              return;
            }
            if (status.loaded) {
              setSurfaceStatus(`Surface: ready${source}`);
              return;
            }
            setSurfaceStatus("Surface: idle");
          } catch (err) {
            setSurfaceStatus("Surface: status error");
          }
        }

        poll();
        window.setInterval(poll, 2_000);
      }

      function wireUi(wasm) {
        const sidePanel = document.getElementById("side-panel");
        const compactTabs = document.getElementById("compact-tabs");
        const compactClose = document.getElementById("compact-panel-close");

        const tabGeneralBtn = document.getElementById("tab-general-btn");
        const tabLayersBtn = document.getElementById("tab-layers-btn");
        const tabFeedsBtn = document.getElementById("tab-feeds-btn");
        const tabCatalogBtn = document.getElementById("tab-catalog-btn");
        const tabSettingsBtn = document.getElementById("tab-settings-btn");
        const tabGeneral = document.getElementById("tab-general");
        const tabLayers = document.getElementById("tab-layers");
        const tabFeeds = document.getElementById("tab-feeds");
        const tabCatalog = document.getElementById("tab-catalog");
        const tabSettings = document.getElementById("tab-settings");

        const feedLayerControls = document.getElementById("feed-layer-controls");
        const feedsList = document.getElementById("feeds-list");
        const feedsEmpty = document.getElementById("feeds-empty");
        const feedsBackendHint = document.getElementById("feeds-backend-hint");
        const feedAddBtn = document.getElementById("feed-add-btn");
        const feedSampleBtn = document.getElementById("feed-sample-btn");
        const feedsRefreshAllBtn = document.getElementById("feeds-refresh-all");

        const feedModal = document.getElementById("feed-modal");
        const feedModalClose = document.getElementById("feed-modal-close");
        const feedName = document.getElementById("feed-name");
        const feedUrl = document.getElementById("feed-url");
        const feedFormat = document.getElementById("feed-format");
        const feedLat = document.getElementById("feed-lat");
        const feedLon = document.getElementById("feed-lon");
        const feedMaxRows = document.getElementById("feed-max-rows");
        const feedCsvSkipRows = document.getElementById("feed-csv-skip-rows");
        const feedCsvHeader = document.getElementById("feed-csv-header");
        const feedCsvSkip = document.getElementById("feed-csv-skip");
        const feedFilter = document.getElementById("feed-filter");
        const feedPreview = document.getElementById("feed-preview");
        const feedTestBtn = document.getElementById("feed-test-btn");
        const feedSaveBtn = document.getElementById("feed-save-btn");

        const aboutModal = document.getElementById("about-modal");
        const aboutModalClose = document.getElementById("about-modal-close");
        const aboutModalOk = document.getElementById("about-modal-ok");

        const catalogList = document.getElementById("catalog-list");
        const catalogEmpty = document.getElementById("catalog-empty");

        const fileGeoJson = document.getElementById("file-geojson");
        const uploadedInfo = document.getElementById("uploaded-info");
        const toggleGraticule = document.getElementById("toggle-graticule");
        const toggleRealSun = document.getElementById("toggle-real-sun");
        const toggleAutoRotate = document.getElementById("toggle-auto-rotate");
        const toggleGlobeTransparent = document.getElementById("toggle-globe-transparent");
        const autoRotateSpeed = document.getElementById("auto-rotate-speed");
        const autoRotateSpeedValue = document.getElementById("auto-rotate-speed-value");
        const themeSelect = document.getElementById("theme-select");
        const citySize = document.getElementById("city-size");
        const citySizeValue = document.getElementById("city-size-value");
        const lineWidth = document.getElementById("line-width");
        const lineWidthValue = document.getElementById("line-width-value");
        const canvas2d = document.getElementById("atlas-canvas-2d");
        const canvas3d = document.getElementById("atlas-canvas-3d");

        // Global input timestamp used by background loaders to pause work.
        const markUserInput = () => {
          try {
            window.__atlasLastInputMs = performance?.now ? performance.now() : Date.now();
          } catch (_) {}
        };

        if (themeSelect) {
          themeSelect.value = normalizeTheme(document.documentElement.dataset.theme || "dark");
          themeSelect.addEventListener("change", (e) => {
            applyTheme(e.target.value, wasm);
          });
        }

        if (toggleGlobeTransparent) {
          // Prefer persisted UI state; fall back to wasm default.
          // Force default to opaque to avoid accidental transparency.
          let initial = false;
          let hasSaved = false;
          try {
            const saved = localStorage.getItem("atlas-globe-transparent");
            if (saved === "true" || saved === "false") {
              hasSaved = true;
              initial = (saved === "true");
            }
          } catch (_) {}

          if (hasSaved && initial) {
            initial = false;
            try { localStorage.setItem("atlas-globe-transparent", "false"); } catch (_) {}
          }

          if (!hasSaved) {
            try {
              const s = wasm.get_globe_settings?.();
              initial = !!s?.transparent;
            } catch (_) {
              initial = false;
            }
          }

          toggleGlobeTransparent.checked = !!initial;
          try { wasm.set_globe_transparent?.(!!initial); } catch (_) {}

          toggleGlobeTransparent.addEventListener("change", (e) => {
            const v = !!e.target.checked;
            try { localStorage.setItem("atlas-globe-transparent", v ? "true" : "false"); } catch (_) {}
            try { wasm.set_globe_transparent(v); } catch (err) { console.error(err); }
          });
        }

        const mode2dBtn = document.getElementById("mode-2d");
        const mode3dBtn = document.getElementById("mode-3d");

        const mapHome = document.getElementById("map-home");
        const mapZoomIn = document.getElementById("map-zoom-in");
        const mapZoomOut = document.getElementById("map-zoom-out");
        const mapView = document.getElementById("map-view");
        const mapCompass = document.getElementById("map-compass");
        const compassNeedle = document.getElementById("compass-needle");
        const mapMode = document.getElementById("map-mode");
        const mapGraticule = document.getElementById("map-graticule");
        const mapSun = document.getElementById("map-sun");
        const mapHelp = document.getElementById("map-help");

        const cursorText = document.getElementById("cursor-text");
        const pickText = document.getElementById("pick-text");

        const layerWorldBase = document.getElementById("layer-world-base");
        const layerWorldBaseColor = document.getElementById("layer-world-base-color");
        const layerWorldBaseOpacity = document.getElementById("layer-world-base-opacity");
        const layerWorldBaseLift = document.getElementById("layer-world-base-lift");

        const layerTerrain = document.getElementById("layer-terrain");

        const layerCities = document.getElementById("layer-cities");
        const layerCitiesColor = document.getElementById("layer-cities-color");
        const layerCitiesOpacity = document.getElementById("layer-cities-opacity");
        const layerCitiesLift = document.getElementById("layer-cities-lift");

        const layerCorridors = document.getElementById("layer-corridors");
        const layerCorridorsColor = document.getElementById("layer-corridors-color");
        const layerCorridorsOpacity = document.getElementById("layer-corridors-opacity");
        const layerCorridorsLift = document.getElementById("layer-corridors-lift");

        const layerRegions = document.getElementById("layer-regions");
        const layerRegionsColor = document.getElementById("layer-regions-color");
        const layerRegionsOpacity = document.getElementById("layer-regions-opacity");
        const layerRegionsLift = document.getElementById("layer-regions-lift");

        const layerUploadedPoints = document.getElementById("layer-uploaded-points");
        const layerUploadedPointsLabel = document.getElementById("layer-uploaded-points-label");
        const layerUploadedPointsColor = document.getElementById("layer-uploaded-points-color");
        const layerUploadedPointsOpacity = document.getElementById("layer-uploaded-points-opacity");
        const layerUploadedPointsLift = document.getElementById("layer-uploaded-points-lift");

        const layerUploadedCorridors = document.getElementById("layer-uploaded-corridors");
        const layerUploadedCorridorsLabel = document.getElementById("layer-uploaded-corridors-label");
        const layerUploadedCorridorsColor = document.getElementById("layer-uploaded-corridors-color");
        const layerUploadedCorridorsOpacity = document.getElementById("layer-uploaded-corridors-opacity");
        const layerUploadedCorridorsLift = document.getElementById("layer-uploaded-corridors-lift");

        const layerUploadedRegions = document.getElementById("layer-uploaded-regions");
        const layerUploadedRegionsLabel = document.getElementById("layer-uploaded-regions-label");
        const layerUploadedRegionsColor = document.getElementById("layer-uploaded-regions-color");
        const layerUploadedRegionsOpacity = document.getElementById("layer-uploaded-regions-opacity");
        const layerUploadedRegionsLift = document.getElementById("layer-uploaded-regions-lift");

        function formatGeometrySummary(points, lines, polygons) {
          const p = Number(points ?? 0);
          const l = Number(lines ?? 0);
          const g = Number(polygons ?? 0);
          const parts = [];
          if (p > 0) parts.push(`Points: ${p}`);
          if (l > 0) parts.push(`Lines: ${l}`);
          if (g > 0) parts.push(`Polygons: ${g}`);
          if (parts.length === 0) return "Empty";
          return parts.join(" • ");
        }

        function setUploadedInfo({ name, points, lines, polygons, catalog_persisted, catalog_error, skipped_coords, fixed_swapped, fixed_web_mercator, error }) {
          if (error) {
            uploadedInfo.innerHTML = `<div style="color:var(--danger);">Upload error: ${String(error)}</div>`;
            return;
          }
          if (!name) {
            uploadedInfo.innerHTML = `<div style="color:var(--muted);">No upload loaded.</div>`;
            return;
          }

          const skipped = Number(skipped_coords ?? 0);
          const swapped = Number(fixed_swapped ?? 0);
          const merc = Number(fixed_web_mercator ?? 0);
          const hasDiag = (skipped + swapped + merc) > 0;
          const persisted = catalog_persisted === undefined ? null : !!catalog_persisted;
          const catErr = String(catalog_error ?? "").trim();

          const geomSummary = formatGeometrySummary(points, lines, polygons);
          uploadedInfo.innerHTML = `
            <div><span style="color:var(--info);">Uploaded:</span> ${name}</div>
            <div style="color:var(--muted);">${geomSummary}</div>
            ${persisted === null ? "" : (persisted ? `<div style="color:var(--success); font-size:12px;">Saved to Catalog.</div>` : `<div style="color:var(--warning); font-size:12px;">Not saved to Catalog.</div>${catErr ? `<div style=\"color:var(--muted); font-size:12px;\">${catErr}</div>` : ``}`) }
            ${hasDiag ? `<div style="color:var(--muted);">Coords: fixed swap ${swapped} • fixed mercator ${merc} • skipped ${skipped}</div>` : ""}
          `;
        }

        function wireLayerControls() {
          function bind(id, checkbox, color, opacity, lift) {
            if (checkbox) {
              checkbox.addEventListener("change", (e) => {
                try { wasm.set_layer_visible(id, !!e.target.checked); } catch (err) { console.error(err); }
              });
            }
            if (color) {
              color.addEventListener("input", (e) => {
                try { wasm.set_layer_color_hex(id, e.target.value); } catch (err) { console.error(err); }
              });
            }
            if (opacity) {
              opacity.addEventListener("input", (e) => {
                try { wasm.set_layer_opacity(id, Number(e.target.value)); } catch (err) { console.error(err); }
              });
            }
            if (lift) {
              lift.addEventListener("input", (e) => {
                try { wasm.set_layer_lift(id, Number(e.target.value)); } catch (err) { console.error(err); }
              });
            }
          }
          bind("world_base", layerWorldBase, layerWorldBaseColor, layerWorldBaseOpacity, layerWorldBaseLift);
          bind("terrain", layerTerrain, null, null, null);
          bind("cities", layerCities, layerCitiesColor, layerCitiesOpacity, layerCitiesLift);
          bind("air_corridors", layerCorridors, layerCorridorsColor, layerCorridorsOpacity, layerCorridorsLift);
          bind("regions", layerRegions, layerRegionsColor, layerRegionsOpacity, layerRegionsLift);
          bind("uploaded_points", layerUploadedPoints, layerUploadedPointsColor, layerUploadedPointsOpacity, layerUploadedPointsLift);
          bind("uploaded_corridors", layerUploadedCorridors, layerUploadedCorridorsColor, layerUploadedCorridorsOpacity, layerUploadedCorridorsLift);
          bind("uploaded_regions", layerUploadedRegions, layerUploadedRegionsColor, layerUploadedRegionsOpacity, layerUploadedRegionsLift);
        }

        wireLayerControls();

        // Persist terrain preference (on/off) across reloads.
        if (layerTerrain) {
          layerTerrain.addEventListener("change", (e) => {
            setTerrainPreference(!!e.target.checked);
          });
        }
        syncSymbologyControls();

        function syncSymbologyControls() {
          function syncLayer(id, checkbox, color, opacity, lift) {
            if (!wasm.get_layer_style) return;
            try {
              const style = wasm.get_layer_style(id);
              if (!style) return;
              if (checkbox) checkbox.checked = !!style.visible;
              if (color && style.color_hex) color.value = style.color_hex;
              if (opacity && style.opacity !== undefined) opacity.value = String(style.opacity);
              if (lift && style.lift !== undefined) lift.value = String(style.lift);
            } catch (err) {
              console.error("get_layer_style failed", err);
            }
          }

          syncLayer("world_base", layerWorldBase, layerWorldBaseColor, layerWorldBaseOpacity, layerWorldBaseLift);
          syncLayer("terrain", layerTerrain, null, null, null);
          syncLayer("cities", layerCities, layerCitiesColor, layerCitiesOpacity, layerCitiesLift);
          syncLayer("air_corridors", layerCorridors, layerCorridorsColor, layerCorridorsOpacity, layerCorridorsLift);
          syncLayer("regions", layerRegions, layerRegionsColor, layerRegionsOpacity, layerRegionsLift);
          syncLayer("uploaded_points", layerUploadedPoints, layerUploadedPointsColor, layerUploadedPointsOpacity, layerUploadedPointsLift);
          syncLayer("uploaded_corridors", layerUploadedCorridors, layerUploadedCorridorsColor, layerUploadedCorridorsOpacity, layerUploadedCorridorsLift);
          syncLayer("uploaded_regions", layerUploadedRegions, layerUploadedRegionsColor, layerUploadedRegionsOpacity, layerUploadedRegionsLift);

          renderFeedLayerControls();

          if (wasm.get_city_marker_size) {
            try {
              const size = wasm.get_city_marker_size();
              citySize.value = String(size);
              citySizeValue.textContent = String(size);
            } catch (err) { console.error("get_city_marker_size failed", err); }
          }
          if (wasm.get_line_width_px) {
            try {
              const width = wasm.get_line_width_px();
              lineWidth.value = String(width);
              lineWidthValue.textContent = String(width);
            } catch (err) { console.error("get_line_width_px failed", err); }
          }
        }

        function setTab(which) {
          const isGeneral = which === "general";
          const isLayers = which === "layers";
          const isFeeds = which === "feeds";
          const isCatalog = which === "catalog";
          const isSettings = which === "settings";

          tabGeneralBtn.classList.toggle("active", isGeneral);
          tabLayersBtn.classList.toggle("active", isLayers);
          tabFeedsBtn.classList.toggle("active", isFeeds);
          tabCatalogBtn.classList.toggle("active", isCatalog);
          tabSettingsBtn.classList.toggle("active", isSettings);

          tabGeneral.classList.toggle("hidden", !isGeneral);
          tabLayers.classList.toggle("hidden", !isLayers);
          tabFeeds.classList.toggle("hidden", !isFeeds);
          tabCatalog.classList.toggle("hidden", !isCatalog);
          tabSettings.classList.toggle("hidden", !isSettings);

          if (isCatalog) {
            renderCatalog();
          }
          if (isFeeds) {
            renderFeeds();
          }
          if (sidePanel && isCompactLayout()) {
            sidePanel.classList.add("compact-open");
          }
        }

        tabGeneralBtn.addEventListener("click", () => setTab("general"));
        tabLayersBtn.addEventListener("click", () => setTab("layers"));
        tabFeedsBtn.addEventListener("click", () => setTab("feeds"));
        tabCatalogBtn.addEventListener("click", () => setTab("catalog"));
        tabSettingsBtn.addEventListener("click", () => setTab("settings"));

        // -----------------
        // Feeds UI + storage
        // -----------------

        const SAMPLE_FEED_URL = "https://data.humdata.org/dataset/a87f96f8-16e6-4d51-872c-cfa54a8251ec/resource/4ef001d1-7888-4f5d-98ce-0ca8006787f7/download/gdacs_rss_information.csv";

        function newId() {
          try { return crypto.randomUUID(); } catch (_) { return "f_" + Math.random().toString(16).slice(2) + "_" + Date.now(); }
        }

        function openFeedModal(seed) {
          if (!feedModal) return;
          feedModal.classList.remove("hidden");
          if (feedPreview) feedPreview.textContent = "Preview will appear after you click “Test download”.";
          if (feedName) feedName.value = String(seed?.name ?? "");
          if (feedUrl) feedUrl.value = String(seed?.url ?? "");
          if (feedFormat) feedFormat.value = String(seed?.format ?? "auto");
          if (feedLat) feedLat.value = String(seed?.latField ?? "");
          if (feedLon) feedLon.value = String(seed?.lonField ?? "");
          if (feedMaxRows) feedMaxRows.value = String(seed?.maxRows ?? 5000);
          if (feedCsvSkipRows) feedCsvSkipRows.value = String(seed?.csvSkipRows ?? 0);
          if (feedCsvHeader) feedCsvHeader.checked = seed?.csvFirstRowHeader !== undefined ? !!seed.csvFirstRowHeader : true;
          if (feedCsvSkip) feedCsvSkip.value = String(seed?.csvSkip ?? "");
          if (feedFilter) feedFilter.value = String(seed?.filter ?? "");

          syncFeedsBackendUi();
        }

        function closeFeedModal() {
          if (!feedModal) return;
          feedModal.classList.add("hidden");
        }

        feedModalClose?.addEventListener("click", closeFeedModal);
        feedModal?.addEventListener("click", (e) => {
          // Click outside modal closes.
          if (e?.target === feedModal) closeFeedModal();
        });

        feedAddBtn?.addEventListener("click", () => openFeedModal());
        feedSampleBtn?.addEventListener("click", () => {
          openFeedModal({ name: "GDACS (sample)", url: SAMPLE_FEED_URL, format: "csv" });
        });

        function getBackendBase() {
          try { return String(window.__atlasBackendUrl || "").trim(); } catch (_) { return ""; }
        }

        function isBackendOnline() {
          return !!getBackendBase();
        }

        function syncFeedsBackendUi() {
          const online = isBackendOnline();
          if (feedAddBtn) feedAddBtn.disabled = !online;
          if (feedSampleBtn) feedSampleBtn.disabled = !online;
          if (feedsRefreshAllBtn) feedsRefreshAllBtn.disabled = !online;
          if (feedTestBtn) feedTestBtn.disabled = !online;
          if (feedSaveBtn) feedSaveBtn.disabled = !online;
          if (feedsBackendHint) {
            feedsBackendHint.textContent = online
              ? `Backend connected (${getBackendBase()})`
              : "Backend offline: feeds are read-only (cache-only).";
          }
          if (feedsEmpty && !online) {
            feedsEmpty.textContent = "Backend offline. Connect the server to add or refresh feeds.";
          } else if (feedsEmpty) {
            feedsEmpty.textContent = "No feeds yet. Click “Add feed…” to get started.";
          }
        }

        // Re-sync when backend detection completes.
        window.addEventListener("atlas-backend-change", () => {
          syncFeedsBackendUi();
          renderFeeds();
        });

        // IndexedDB (feeds store)
        const FEEDS_DB_NAME = "atlas-feeds";
        const FEEDS_DB_VERSION = 1;
        const FEEDS_STORE = "feeds";

        function openFeedsDb() {
          return new Promise((resolve, reject) => {
            if (!window.indexedDB) {
              reject(new Error("IndexedDB not available"));
              return;
            }
            const req = indexedDB.open(FEEDS_DB_NAME, FEEDS_DB_VERSION);
            req.onupgradeneeded = () => {
              const db = req.result;
              if (!db.objectStoreNames.contains(FEEDS_STORE)) {
                const store = db.createObjectStore(FEEDS_STORE, { keyPath: "id" });
                store.createIndex("byUpdatedAt", "updatedAt", { unique: false });
              }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error || new Error("Failed to open IndexedDB"));
          });
        }

        async function idbGetAllFeeds() {
          const db = await openFeedsDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction([FEEDS_STORE], "readonly");
            const store = tx.objectStore(FEEDS_STORE);
            const req = store.getAll();
            req.onsuccess = () => resolve(req.result || []);
            req.onerror = () => reject(req.error || new Error("Failed to list feeds"));
          });
        }

        async function idbPutFeed(feed) {
          const db = await openFeedsDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction([FEEDS_STORE], "readwrite");
            const store = tx.objectStore(FEEDS_STORE);
            const req = store.put(feed);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error || new Error("Failed to save feed"));
          });
        }

        async function idbDeleteFeed(id) {
          const db = await openFeedsDb();
          return new Promise((resolve, reject) => {
            const tx = db.transaction([FEEDS_STORE], "readwrite");
            const store = tx.objectStore(FEEDS_STORE);
            const req = store.delete(id);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error || new Error("Failed to delete feed"));
          });
        }

        function guessFormatFromUrl(url) {
          const u = String(url || "").toLowerCase();
          if (u.endsWith(".csv")) return "csv";
          if (u.endsWith(".json") || u.endsWith(".geojson")) return "json";
          if (u.endsWith(".rss") || u.endsWith(".xml")) return "rss";
          return "auto";
        }

        function normalizeFieldName(s) {
          return String(s || "").trim().toLowerCase().replace(/\s+/g, "_");
        }

        function detectLatLonFields(keys) {
          const k = (keys || []).map(normalizeFieldName);
          const latCandidates = ["lat", "latitude", "y", "lat_deg", "y_lat", "geo_lat", "location_lat"];
          const lonCandidates = ["lon", "lng", "longitude", "x", "lon_deg", "x_lon", "geo_lon", "location_lon", "long"];
          const find = (cands) => {
            for (const c of cands) {
              const idx = k.indexOf(c);
              if (idx >= 0) return keys[idx];
            }
            return "";
          };
          return { lat: find(latCandidates), lon: find(lonCandidates) };
        }

        function parseRowSkipSpec(specText) {
          const spec = String(specText || "").trim();
          if (!spec) return [];

          const parts = spec.split(",").map((s) => s.trim()).filter(Boolean);
          const ranges = [];
          for (const p of parts) {
            const m = p.match(/^([0-9]+)\s*-\s*([0-9]+)$/);
            if (m) {
              const a = Number(m[1]);
              const b = Number(m[2]);
              if (!Number.isFinite(a) || !Number.isFinite(b) || a <= 0 || b <= 0) continue;
              const start = Math.min(a, b);
              const end = Math.max(a, b);
              ranges.push([start, end]);
              continue;
            }
            const n = Number(p);
            if (Number.isFinite(n) && n > 0) {
              ranges.push([Math.floor(n), Math.floor(n)]);
            }
          }

          if (!ranges.length) throw new Error("Invalid CSV skip rows spec. Use e.g. 2,5,10-12");
          ranges.sort((x, y) => x[0] - y[0]);

          // Merge overlaps.
          const merged = [];
          for (const r of ranges) {
            const last = merged[merged.length - 1];
            if (!last || r[0] > last[1] + 1) {
              merged.push([r[0], r[1]]);
            } else {
              last[1] = Math.max(last[1], r[1]);
            }
          }
          return merged;
        }

        function isIndexInRanges(idx1Based, ranges) {
          if (!ranges || !ranges.length) return false;
          for (const [a, b] of ranges) {
            if (idx1Based < a) return false;
            if (idx1Based >= a && idx1Based <= b) return true;
          }
          return false;
        }

        function parseCsv(text, delimiter, options) {
          const src = String(text || "");
          const opts = options || {};
          const skipRows = Math.max(0, Math.floor(Number(opts.skipRows) || 0));
          const firstRowHeader = opts.firstRowHeader !== undefined ? !!opts.firstRowHeader : true;
          const skipSpecText = String(opts.skip || "");
          const skipRanges = skipSpecText.trim().length ? parseRowSkipSpec(skipSpecText) : [];

          const linesAll = src.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
          const nonEmptyAll = linesAll.filter((l) => String(l).trim().length > 0);
          const nonEmpty = nonEmptyAll.filter((_, idx0) => {
            const idx1 = idx0 + 1;
            if (skipRows > 0 && idx1 <= skipRows) return false;
            if (skipRanges.length && isIndexInRanges(idx1, skipRanges)) return false;
            return true;
          });
          if (nonEmpty.length === 0) return { headers: [], rows: [] };

          const head = nonEmpty[0];
          const guessDelim = () => {
            const candidates = [",", "\t", ";", "|"];
            let best = ",";
            let bestCount = -1;
            for (const d of candidates) {
              const count = head.split(d).length;
              if (count > bestCount) { bestCount = count; best = d; }
            }
            return best;
          };
          const delim = delimiter && String(delimiter).length ? String(delimiter) : guessDelim();

          const splitLine = (line) => {
            const out = [];
            let cur = "";
            let inQuotes = false;
            for (let i = 0; i < line.length; i++) {
              const ch = line[i];
              if (ch === '"') {
                const next = line[i + 1];
                if (inQuotes && next === '"') {
                  cur += '"';
                  i++;
                } else {
                  inQuotes = !inQuotes;
                }
              } else if (!inQuotes && ch === delim) {
                out.push(cur);
                cur = "";
              } else {
                cur += ch;
              }
            }
            out.push(cur);
            return out.map((v) => String(v).trim());
          };

          const rows = [];
          let headers = [];

          if (firstRowHeader) {
            headers = splitLine(nonEmpty[0]).map((h, idx) => String(h || `col_${idx}`).trim() || `col_${idx}`);
            const dataLinesAll = nonEmpty.slice(1);

            // HDX datasets sometimes include a second "tagged" header row like:
            //   #event+id,#country+code,...
            // If present, skip it.
            const shouldSkipAsSecondHeader = (line) => {
              const t = String(line || "").trim();
              if (!t) return false;
              if (t.startsWith("#")) return true;
              const parts = splitLine(t);
              if (!parts.length) return false;
              const hashy = parts.filter((p) => String(p || "").trim().startsWith("#")).length;
              if (hashy >= Math.max(2, Math.floor(parts.length * 0.6))) return true;
              if (t.includes("#event+id") || t.includes("#geo+lat") || t.includes("#geo+lon")) return true;
              return false;
            };

            const dataLines = (dataLinesAll.length && shouldSkipAsSecondHeader(dataLinesAll[0]))
              ? dataLinesAll.slice(1)
              : dataLinesAll;

            for (const line of dataLines) {
              const parts = splitLine(line);
              const row = {};
              for (let i = 0; i < headers.length; i++) row[headers[i]] = parts[i] ?? "";
              rows.push(row);
            }
          } else {
            // Treat first row as data; generate generic headers based on its column count.
            const firstParts = splitLine(nonEmpty[0]);
            headers = firstParts.map((_, idx) => `col_${idx}`);
            const pushParts = (parts) => {
              const row = {};
              for (let i = 0; i < headers.length; i++) row[headers[i]] = parts[i] ?? "";
              rows.push(row);
            };
            pushParts(firstParts);
            for (const line of nonEmpty.slice(1)) pushParts(splitLine(line));
          }
          return { headers, rows };
        }

        function parseRss(text) {
          const src = String(text || "");
          const parser = new DOMParser();
          const doc = parser.parseFromString(src, "text/xml");
          const items = Array.from(doc.querySelectorAll("item"));
          const rows = [];
          for (const item of items) {
            const getText = (sel) => {
              const el = item.querySelector(sel);
              return el ? String(el.textContent || "").trim() : "";
            };
            const title = getText("title");
            const link = getText("link");
            const pubDate = getText("pubDate");
            const guid = getText("guid");

            let lat = getText("geo\\:lat") || getText("lat");
            let lon = getText("geo\\:long") || getText("geo\\:lon") || getText("long") || getText("lon");
            const point = getText("georss\\:point");
            if ((!lat || !lon) && point) {
              const parts = point.split(/\s+/).map((v) => v.trim()).filter(Boolean);
              if (parts.length >= 2) {
                lat = lat || parts[0];
                lon = lon || parts[1];
              }
            }

            rows.push({ title, link, pubDate, guid, lat, lon });
          }
          return { headers: ["title", "link", "pubDate", "guid", "lat", "lon"], rows };
        }

        function applySimpleFilter(rows, filterText) {
          const f = String(filterText || "").trim();
          if (!f) return rows;
          const m = f.match(/^(.+?)\s+contains\s+(.+)$/i);
          if (!m) return rows;
          const field = String(m[1] || "").trim();
          const needle = String(m[2] || "").trim().toLowerCase();
          if (!field || !needle) return rows;
          return rows.filter((r) => String(r?.[field] ?? "").toLowerCase().includes(needle));
        }

        function toNumber(v) {
          if (v === null || v === undefined) return NaN;
          const s = String(v).trim();
          if (!s) return NaN;
          return Number(s);
        }

        function rowsToGeoJsonPoints(rows, latField, lonField, maxRows) {
          const feats = [];
          const limit = Number(maxRows || 5000);
          const n = Math.min(rows.length, Number.isFinite(limit) ? limit : rows.length);
          for (let i = 0; i < n; i++) {
            const r = rows[i];
            const lat = toNumber(r?.[latField]);
            const lon = toNumber(r?.[lonField]);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) continue;
            if (Math.abs(lat) > 90 || Math.abs(lon) > 1800) continue;
            feats.push({
              type: "Feature",
              geometry: { type: "Point", coordinates: [lon, lat] },
              properties: { ...r },
            });
          }
          return { type: "FeatureCollection", features: feats };
        }

        function inferFormat(selected, url, contentType) {
          const s = String(selected || "auto");
          if (s !== "auto") return s;
          const byUrl = guessFormatFromUrl(url);
          if (byUrl !== "auto") return byUrl;
          const ct = String(contentType || "").toLowerCase();
          if (ct.includes("application/json") || ct.includes("geo+json")) return "json";
          if (ct.includes("text/csv") || ct.includes("application/csv")) return "csv";
          if (ct.includes("application/rss+xml") || ct.includes("application/xml") || ct.includes("text/xml")) return "rss";
          return "csv";
        }

        async function backendFetch(path, options, timeoutMs) {
          const base = getBackendBase();
          if (!base) throw new Error("Backend offline");
          const resp = await fetchWithTimeout(`${base}${path}`, options || {}, timeoutMs ?? 6_000);
          return resp;
        }

        async function backendFetchJson(path, options, timeoutMs) {
          const resp = await backendFetch(path, {
            headers: {
              "content-type": "application/json",
              ...(options?.headers || {}),
            },
            ...(options || {}),
          }, timeoutMs);

          const ct = String(resp.headers.get("content-type") || "").toLowerCase();
          const payload = ct.includes("application/json") ? await resp.json().catch(() => null) : await resp.text().catch(() => "");

          if (!resp.ok) {
            const msg = String(payload?.error || payload || `HTTP ${resp.status}`);
            throw new Error(msg);
          }
          return payload;
        }

        async function serverListFeeds() {
          const data = await backendFetchJson("/api/feeds", { method: "GET" }, 2_500);
          return Array.isArray(data) ? data : [];
        }

        async function serverUpsertFeed(feedSpec) {
          return await backendFetchJson("/api/feeds", { method: "POST", body: JSON.stringify(feedSpec) }, 4_000);
        }

        async function serverDeleteFeed(id) {
          const resp = await backendFetch(`/api/feeds/${encodeURIComponent(String(id))}`, { method: "DELETE" }, 4_000);
          if (!resp.ok) {
            let msg = `HTTP ${resp.status}`;
            try {
              const j = await resp.json();
              msg = String(j?.error || msg);
            } catch (_) {}
            throw new Error(msg);
          }
          return true;
        }

        async function serverFetchFeedById(id) {
          return await backendFetchJson(`/api/feeds/${encodeURIComponent(String(id))}/fetch`, { method: "GET" }, 8_000);
        }

        async function serverFetchUrl(url) {
          return await backendFetchJson("/api/feeds/fetch", { method: "POST", body: JSON.stringify({ url }) }, 8_000);
        }

        function formatFetchError(err) {
          const msg = String(err?.message ?? err ?? "");
          if (!navigator.onLine) return "Offline: can’t download right now.";
          // Browsers commonly throw TypeError: Failed to fetch for CORS/blocked/handshake.
          if (msg.toLowerCase().includes("failed to fetch") || msg.toLowerCase().includes("networkerror")) {
            return "Download blocked (likely CORS). This host didn’t allow cross-origin requests.";
          }
          return msg || "Download failed.";
        }

        async function buildGeoJsonFromFeed(feed, text, contentType) {
          const fmt = inferFormat(feed.format, feed.url, contentType);
          if (fmt === "json") {
            let obj;
            try { obj = JSON.parse(text); } catch (e) { throw new Error("Invalid JSON"); }
            // GeoJSON passthrough.
            if (obj && obj.type === "FeatureCollection" && Array.isArray(obj.features)) {
              return obj;
            }
            // Array-of-objects.
            const rows = Array.isArray(obj) ? obj : (Array.isArray(obj?.items) ? obj.items : (Array.isArray(obj?.results) ? obj.results : []));
            if (!Array.isArray(rows) || rows.length === 0) throw new Error("JSON must be GeoJSON or an array of objects");
            const keys = Object.keys(rows[0] || {});
            const detected = detectLatLonFields(keys);
            const latField = String(feed.latField || detected.lat || "");
            const lonField = String(feed.lonField || detected.lon || "");
            if (!latField || !lonField) {
              throw new Error("Could not detect latitude/longitude fields. Please specify them.");
            }
            const filtered = applySimpleFilter(rows, feed.filter);
            return rowsToGeoJsonPoints(filtered, latField, lonField, feed.maxRows);
          }

          if (fmt === "rss") {
            const { rows } = parseRss(text);
            const keys = rows.length ? Object.keys(rows[0]) : [];
            const detected = detectLatLonFields(keys);
            const latField = String(feed.latField || detected.lat || "lat");
            const lonField = String(feed.lonField || detected.lon || "lon");
            const filtered = applySimpleFilter(rows, feed.filter);
            return rowsToGeoJsonPoints(filtered, latField, lonField, feed.maxRows);
          }

          // CSV default
          const { rows } = parseCsv(text, undefined, {
            skipRows: Number(feed.csvSkipRows ?? 0),
            skip: String(feed.csvSkip ?? ""),
            firstRowHeader: feed.csvFirstRowHeader !== undefined ? !!feed.csvFirstRowHeader : true,
          });
          if (!rows.length) throw new Error("CSV appears empty");
          const keys = Object.keys(rows[0] || {});
          const detected = detectLatLonFields(keys);
          const latField = String(feed.latField || detected.lat || "");
          const lonField = String(feed.lonField || detected.lon || "");
          if (!latField || !lonField) {
            throw new Error("Could not detect latitude/longitude columns. Please specify them.");
          }
          const filtered = applySimpleFilter(rows, feed.filter);
          return rowsToGeoJsonPoints(filtered, latField, lonField, feed.maxRows);
        }

        async function loadFeedIntoScene(feed, geojsonObj) {
          const feedLayerId = `feed:${feed.id}`;
          const text = JSON.stringify(geojsonObj);
          const summary = wasm.load_geojson_feed_layer?.(feedLayerId, feed.name, text);
          return summary;
        }

        async function refreshFeed(feed, { allowCacheOnly } = {}) {
          const f = { ...feed };
          const now = Date.now();
          try {
            if (!allowCacheOnly) {
              setStatus(`Downloading feed: ${f.name}…`);
              if (!isBackendOnline()) throw new Error("Backend offline");
              const fetched = await serverFetchFeedById(f.id);
              const text = String(fetched?.text ?? "");
              const contentType = String(fetched?.contentType ?? "");
              const geo = await buildGeoJsonFromFeed(f, text, contentType);
              const summary = await loadFeedIntoScene(f, geo);
              f.lastError = "";
              f.lastOkAt = now;
              // Best-effort cache snapshot (avoid giant entries)
              const geoText = JSON.stringify(geo);
              if (geoText.length <= 2_500_000) {
                f.cachedGeojson = geoText;
                f.cachedAt = now;
              }
              f.updatedAt = now;
              await idbPutFeed(f);
              renderFeeds();
              setStatus(`Feed loaded: ${f.name} (${Number(summary?.points ?? geo.features?.length ?? 0)} pts)`);
              return;
            }

            if (f.cachedGeojson) {
              setStatus(`Loading cached feed: ${f.name}…`);
              const geo = JSON.parse(f.cachedGeojson);
              await loadFeedIntoScene(f, geo);
              setStatus(`Feed loaded from cache: ${f.name}`);
              return;
            }
            throw new Error("No cached data available");
          } catch (err) {
            const msg = formatFetchError(err);
            f.lastError = msg;
            f.updatedAt = now;
            await idbPutFeed(f);
            renderFeeds();
            setStatus(`Feed error: ${f.name} (${msg})`);
          }
        }

        async function renderFeeds() {
          if (!feedsList || !feedsEmpty) return;

          let localFeeds = [];
          try { localFeeds = await idbGetAllFeeds(); } catch (err) { localFeeds = []; }

          const online = isBackendOnline();
          let feeds = [];

          if (online) {
            try {
              const serverFeeds = await serverListFeeds();
              const byId = new Map((localFeeds || []).map((f) => [String(f?.id ?? ""), f]));
              feeds = (serverFeeds || []).map((sf) => {
                const id = String(sf?.id ?? "");
                const local = byId.get(id) || {};
                const mergedUpdatedAt = Math.max(Number(local?.updatedAt ?? 0), Number(sf?.updatedAt ?? 0));
                return {
                  ...local,
                  ...sf,
                  updatedAt: mergedUpdatedAt,
                  lastOkAt: Number(local?.lastOkAt ?? 0),
                  lastError: String(local?.lastError ?? ""),
                  cachedGeojson: String(local?.cachedGeojson ?? ""),
                  cachedAt: Number(local?.cachedAt ?? 0),
                };
              });

              // Best-effort sync to browser store (keep cached snapshots).
              for (const f of feeds) {
                // eslint-disable-next-line no-await-in-loop
                await idbPutFeed(f);
              }
            } catch (err) {
              console.warn("server feeds list failed; using local cache", err);
              feeds = localFeeds;
            }
          } else {
            feeds = localFeeds;
          }

          feeds.sort((a, b) => Number(b?.updatedAt ?? 0) - Number(a?.updatedAt ?? 0));
          feedsList.innerHTML = "";
          feedsEmpty.style.display = feeds.length ? "none" : "block";
          if (!feeds.length) return;

          for (const feed of feeds) {
            const row = document.createElement("div");
            row.className = "section";
            row.style.padding = "10px";
            const err = String(feed?.lastError ?? "").trim();
            const okAt = Number(feed?.lastOkAt ?? 0);
            const okText = okAt ? new Date(okAt).toLocaleString() : "—";
            const cacheAt = Number(feed?.cachedAt ?? 0);
            const cacheText = cacheAt ? new Date(cacheAt).toLocaleString() : "—";
            row.innerHTML = `
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:800;">${String(feed?.name ?? "Unnamed")}</div>
                <span class="pill">${String(feed?.format ?? "auto")}</span>
              </div>
              <div style="font-size:12px; color:var(--muted); margin-top:6px; word-break:break-word;">${String(feed?.url ?? "")}</div>
              <div style="font-size:12px; color:var(--muted); margin-top:6px;">Last ok: ${okText} • Cached: ${cacheText}</div>
              ${err ? `<div style="font-size:12px; margin-top:6px; color:var(--warning);">${err}</div>` : ``}
              <div style="display:flex; gap:8px; margin-top:10px; flex-wrap:wrap;">
                <button type="button" data-action="refresh" ${!isBackendOnline() ? "disabled" : ""}>Fetch & load</button>
                <button type="button" data-action="cache">Load cache</button>
                <button type="button" data-action="remove" style="border-color:#7f1d1d;">Remove</button>
              </div>
            `;

            const btnRefresh = row.querySelector('button[data-action="refresh"]');
            const btnCache = row.querySelector('button[data-action="cache"]');
            const btnRemove = row.querySelector('button[data-action="remove"]');

            btnRefresh?.addEventListener("click", () => refreshFeed(feed, { allowCacheOnly: false }));
            btnCache?.addEventListener("click", () => refreshFeed(feed, { allowCacheOnly: true }));
            btnRemove?.addEventListener("click", async () => {
              try {
                if (isBackendOnline()) {
                  await serverDeleteFeed(feed.id);
                }
                await idbDeleteFeed(feed.id);
                try { wasm.remove_feed_layer?.(`feed:${feed.id}`); } catch (_) {}
                renderFeeds();
                renderFeedLayerControls();
              } catch (err) {
                console.error("delete feed failed", err);
              }
            });

            feedsList.appendChild(row);
          }
        }

        function renderFeedLayerControls() {
          if (!feedLayerControls) return;
          feedLayerControls.innerHTML = "";
          if (!wasm.list_feed_layers) return;
          let layers = [];
          try { layers = wasm.list_feed_layers() ?? []; } catch (err) { layers = []; }
          if (!Array.isArray(layers) || layers.length === 0) return;

          for (const l of layers) {
            const id = String(l?.id ?? "");
            const name = String(l?.name ?? id);
            const pts = Number(l?.points ?? 0);

            const row = document.createElement("div");
            row.className = "layer-row";
            row.innerHTML = `
              <label class="checkbox">
                <input type="checkbox" data-role="visible" ${l?.visible ? "checked" : ""} />
                <span>${name} <span class="pill">${pts} pts</span></span>
              </label>
              <input type="color" data-role="color" value="${String(l?.color_hex ?? "#60a5fa")}" />
              <div>
                <div class="mini">Opacity</div>
                <input type="range" data-role="opacity" min="0" max="1" step="0.01" value="${String(l?.opacity ?? 0.95)}" />
              </div>
              <div>
                <div class="mini">Lift</div>
                <input type="range" data-role="lift" min="-0.02" max="0.05" step="0.001" value="${String(l?.lift ?? 0.0)}" />
              </div>
            `;

            const vis = row.querySelector('input[data-role="visible"]');
            const color = row.querySelector('input[data-role="color"]');
            const opacity = row.querySelector('input[data-role="opacity"]');
            const lift = row.querySelector('input[data-role="lift"]');

            vis?.addEventListener("change", (e) => { try { wasm.set_layer_visible(id, !!e.target.checked); } catch (err) { console.error(err); } });
            color?.addEventListener("input", (e) => { try { wasm.set_layer_color_hex(id, e.target.value); } catch (err) { console.error(err); } });
            opacity?.addEventListener("input", (e) => { try { wasm.set_layer_opacity(id, Number(e.target.value)); } catch (err) { console.error(err); } });
            lift?.addEventListener("input", (e) => { try { wasm.set_layer_lift(id, Number(e.target.value)); } catch (err) { console.error(err); } });

            feedLayerControls.appendChild(row);
          }
        }

        feedsRefreshAllBtn?.addEventListener("click", async () => {
          try {
            if (!isBackendOnline()) {
              setStatus("Backend offline: can't refresh feeds");
              return;
            }
            const feeds = await idbGetAllFeeds();
            for (const f of feeds) {
              // Serialize to avoid hammering the network.
              // eslint-disable-next-line no-await-in-loop
              await refreshFeed(f, { allowCacheOnly: false });
            }
          } catch (err) {
            console.error("refresh all failed", err);
          }
        });

        feedTestBtn?.addEventListener("click", async () => {
          if (!isBackendOnline()) {
            if (feedPreview) feedPreview.textContent = "Backend offline: can't test downloads.";
            return;
          }
          const url = String(feedUrl?.value ?? "").trim();
          const name = String(feedName?.value ?? "").trim() || "Untitled feed";
          const format = String(feedFormat?.value ?? "auto");
          const latField = String(feedLat?.value ?? "").trim();
          const lonField = String(feedLon?.value ?? "").trim();
          const maxRows = Number(feedMaxRows?.value ?? 5000);
          const csvSkipRows = Math.max(0, Math.floor(Number(feedCsvSkipRows?.value ?? 0) || 0));
          const csvFirstRowHeader = feedCsvHeader ? !!feedCsvHeader.checked : true;
          const csvSkip = String(feedCsvSkip?.value ?? "").trim();
          const filter = String(feedFilter?.value ?? "").trim();
          if (!url) {
            if (feedPreview) feedPreview.textContent = "Please provide a URL.";
            return;
          }
          const tmp = { id: "_tmp", name, url, format, latField, lonField, maxRows, csvSkipRows, csvSkip, csvFirstRowHeader, filter };
          try {
            if (feedPreview) feedPreview.textContent = "Downloading…";
            const fetched = await serverFetchUrl(url);
            const text = String(fetched?.text ?? "");
            const contentType = String(fetched?.contentType ?? "");
            const geo = await buildGeoJsonFromFeed(tmp, text, contentType);
            const pts = Array.isArray(geo?.features) ? geo.features.length : 0;
            const detectedFmt = inferFormat(format, url, contentType);
            if (feedPreview) {
              feedPreview.innerHTML = `
                <div><span style="color:var(--success); font-weight:700;">OK</span> <span class="pill">${detectedFmt}</span></div>
                <div style="margin-top:6px;">Parsed points: <span style="color:var(--info); font-weight:700;">${pts}</span></div>
                <div style="margin-top:6px; color:var(--muted);">If points look wrong, specify latitude/longitude fields.</div>
              `;
            }
          } catch (err) {
            const msg = formatFetchError(err);
            if (feedPreview) feedPreview.innerHTML = `<div style="color:var(--warning);">${msg}</div>`;
          }
        });

        feedSaveBtn?.addEventListener("click", async () => {
          if (!isBackendOnline()) {
            if (feedPreview) feedPreview.textContent = "Backend offline: can't save feeds.";
            return;
          }
          const url = String(feedUrl?.value ?? "").trim();
          const name = String(feedName?.value ?? "").trim() || "Untitled feed";
          const format = String(feedFormat?.value ?? guessFormatFromUrl(url));
          const latField = String(feedLat?.value ?? "").trim();
          const lonField = String(feedLon?.value ?? "").trim();
          const maxRows = Number(feedMaxRows?.value ?? 5000);
          const csvSkipRows = Math.max(0, Math.floor(Number(feedCsvSkipRows?.value ?? 0) || 0));
          const csvFirstRowHeader = feedCsvHeader ? !!feedCsvHeader.checked : true;
          const csvSkip = String(feedCsvSkip?.value ?? "").trim();
          const filter = String(feedFilter?.value ?? "").trim();

          if (!url) {
            if (feedPreview) feedPreview.textContent = "Please provide a URL.";
            return;
          }

          const id = newId();
          const feedSpec = {
            id,
            name,
            url,
            format,
            latField,
            lonField,
            maxRows,
            csvSkipRows,
            csvSkip,
            csvFirstRowHeader,
            filter,
          };

          try {
            const saved = await serverUpsertFeed(feedSpec);
            const feed = {
              ...saved,
              lastOkAt: 0,
              lastError: "",
              cachedGeojson: "",
              cachedAt: 0,
            };
            await idbPutFeed(feed);
            closeFeedModal();
            renderFeeds();
            // Auto-fetch once.
            await refreshFeed(feed, { allowCacheOnly: false });
            renderFeedLayerControls();
          } catch (err) {
            console.error("save feed failed", err);
            setStatus("Failed to save feed (see console)");
          }
        });

        // Initial feed render.
        syncFeedsBackendUi();
        renderFeeds();
        renderFeedLayerControls();

        if (compactTabs) {
          compactTabs.querySelectorAll("button[data-tab]").forEach((btn) => {
            btn.addEventListener("click", () => {
              const tab = btn.getAttribute("data-tab");
              if (tab) setTab(tab);
            });
          });
        }
        if (compactClose && sidePanel) {
          compactClose.addEventListener("click", () => {
            sidePanel.classList.remove("compact-open");
          });
        }

        // Start closed on compact layouts; opened by the right-side tab buttons.
        if (sidePanel && isCompactLayout()) {
          sidePanel.classList.remove("compact-open");
        }

        function applyUploadedSummary(summary, labelName) {
          const displayName = labelName || summary?.name || "uploaded";

          setUploadedInfo({
            name: displayName,
            points: summary?.points ?? 0,
            lines: summary?.lines ?? 0,
            polygons: summary?.polygons ?? 0,
          });

          layerUploadedPointsLabel.textContent = `Uploaded points (${displayName})`;
          layerUploadedCorridorsLabel.textContent = `Uploaded lines (${displayName})`;
          layerUploadedRegionsLabel.textContent = `Uploaded polygons (${displayName})`;
          const hasPoints = (summary?.points ?? 0) > 0;
          const hasLines = (summary?.lines ?? 0) > 0;
          const hasPolys = (summary?.polygons ?? 0) > 0;

          layerUploadedPoints.checked = hasPoints;
          layerUploadedCorridors.checked = hasLines;
          layerUploadedRegions.checked = hasPolys;

          try { wasm.set_layer_visible("uploaded_points", hasPoints); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_corridors", hasLines); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_regions", hasPolys); } catch (err) { /* ignore */ }
        }

        function clearUploadedUi() {
          setUploadedInfo({ name: "", points: 0, lines: 0, polygons: 0 });
          layerUploadedPointsLabel.textContent = "Uploaded points";
          layerUploadedCorridorsLabel.textContent = "Uploaded lines";
          layerUploadedRegionsLabel.textContent = "Uploaded polygons";
          layerUploadedPoints.checked = false;
          layerUploadedCorridors.checked = false;
          layerUploadedRegions.checked = false;
          try { wasm.set_layer_visible("uploaded_points", false); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_corridors", false); } catch (err) { /* ignore */ }
          try { wasm.set_layer_visible("uploaded_regions", false); } catch (err) { /* ignore */ }
        }

        async function renderCatalog() {
          if (!catalogList || !catalogEmpty) return;

          let entries = [];
          let builtins = [];
          try {
            entries = wasm.catalog_list?.() ?? [];
          } catch (err) {
            console.error("catalog_list failed", err);
            entries = [];
          }

          try {
            builtins = wasm.get_builtin_layers?.() ?? [];
          } catch (err) {
            builtins = [];
          }

          let currentCatalogId = "";
          try {
            const s = wasm.get_uploaded_summary?.();
            currentCatalogId = String(s?.catalog_id ?? "");
          } catch (err) {
            currentCatalogId = "";
          }

          catalogList.innerHTML = "";
          if (!Array.isArray(entries)) entries = [];
          if (!Array.isArray(builtins)) builtins = [];
          const allEntries = [...builtins, ...entries];
          const hasAny = allEntries.length > 0;
          catalogEmpty.style.display = hasAny ? "none" : "block";
          if (!hasAny) return;

          for (const e of allEntries) {
            const id = String(e?.id ?? "");
            const name = String(e?.name ?? id);
            const pts = Number(e?.points ?? 0);
            const lines = Number(e?.lines ?? 0);
            const polys = Number(e?.polygons ?? 0);
            const isBuiltin = !!e?.builtin;
            let loaded = false;
            if (isBuiltin) {
              try {
                const style = wasm.get_layer_style?.(id);
                loaded = !!style?.visible;
              } catch (err) {
                loaded = false;
              }
            } else {
              loaded = id && currentCatalogId && id === currentCatalogId;
            }
            const geomSummary = formatGeometrySummary(pts, lines, polys);

            const row = document.createElement("div");
            row.className = "section";
            row.style.padding = "10px";
            row.innerHTML = `
              <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
                <div style="font-weight:700;">${name}</div>
                ${loaded ? '<div style="font-size:11px; color:#86efac; font-weight:700;">Loaded</div>' : ''}
              </div>
              <div style="font-size:12px; color:var(--muted); margin-top:6px;">${geomSummary}</div>
              <div style="display:flex; gap:8px; margin-top:10px;">
                <button type="button" data-action="toggle">${loaded ? "Remove from scene" : "Add to scene"}</button>
                ${isBuiltin ? '' : '<button type="button" data-action="delete" style="border-color:#7f1d1d;">Delete</button>'}
              </div>
            `;

            const btnToggle = row.querySelector('button[data-action="toggle"]');
            const btnDelete = row.querySelector('button[data-action="delete"]');

            btnToggle?.addEventListener("click", async () => {
              try {
                if (isBuiltin) {
                  const nextVisible = !loaded;
                  wasm.set_layer_visible?.(id, nextVisible);
                  syncSymbologyControls();
                  renderCatalog();
                } else {
                  if (loaded) {
                    wasm.clear_uploaded?.();
                    clearUploadedUi();
                  } else {
                    const summary = await wasm.catalog_load(id);
                    applyUploadedSummary(summary, name);
                  }
                  renderCatalog();
                }
              } catch (err) {
                console.error("catalog toggle failed", err);
                setStatus("Catalog load failed (see console)");
              }
            });

            btnDelete?.addEventListener("click", async () => {
              try {
                if (loaded) {
                  wasm.clear_uploaded?.();
                  clearUploadedUi();
                }
                await wasm.catalog_delete(id);
                renderCatalog();
              } catch (err) {
                console.error("catalog delete failed", err);
                setStatus("Catalog delete failed (see console)");
              }
            });

            catalogList.appendChild(row);
          }
        }

        // Initial render.
        renderCatalog();

        // Use the global viewMode (initialized at module top).
        // Re-validate from localStorage here if needed.
        {
          const saved = (localStorage.getItem("atlas.viewMode") || "3d").toLowerCase();
          viewMode = (saved === "2d" || saved === "3d") ? saved : "3d";
        }

        function applyViewMode(next) {
          next = String(next || "").toLowerCase();
          if (next !== "2d" && next !== "3d") return;
          viewMode = next;
          try { localStorage.setItem("atlas.viewMode", viewMode); } catch (e) { /* ignore */ }
          canvas2d.classList.toggle("hidden", viewMode !== "2d");
          // Keep WebGPU surface visible in both modes: the 2D path now renders via WebGPU too.
          canvas3d.classList.toggle("hidden", false);
          mode2dBtn?.classList.toggle("active", viewMode === "2d");
          mode3dBtn?.classList.toggle("active", viewMode === "3d");
          if (mapView) mapView.textContent = viewMode.toUpperCase();
          try { wasm.set_view_mode(viewMode); } catch (err) { console.error("set_view_mode failed", err); }
          updateCompass();
        }

        mode2dBtn?.addEventListener("click", () => applyViewMode("2d"));
        mode3dBtn?.addEventListener("click", () => applyViewMode("3d"));
        mapView?.addEventListener("click", () => applyViewMode(viewMode === "2d" ? "3d" : "2d"));

        function activeCanvas() {
          return viewMode === "2d" ? canvas2d : canvas3d;
        }

        for (const c of [canvas2d, canvas3d]) {
          c.addEventListener("contextmenu", (e) => e.preventDefault());
        }

        function updateCompass() {
          if (!compassNeedle) return;
          let yawDeg = 0;
          if (viewMode === "3d") {
            try {
              yawDeg = Number(wasm.get_camera_yaw_deg?.() ?? 0);
            } catch (err) {
              yawDeg = 0;
            }
          }
          // Rotate needle opposite to yaw so it represents North on screen.
          const rot = -yawDeg;
          compassNeedle.style.transform = `translate(-50%, -100%) rotate(${rot}deg)`;
        }

        // Expose for optional callers.
        window.__atlasUpdateCompass = updateCompass;

        mapCompass?.addEventListener("click", () => {
          // Reset yaw to a north-up orientation without resetting distance/pitch.
          try {
            wasm.set_camera_yaw_deg(0);
          } catch (err) {
            // ignore
          }
          updateCompass();
        });

        let dragging = false;
        let dragMode = "orbit"; // orbit | pan
        let lockMode = "auto"; // auto | orbit | pan
        let lastX = 0;
        let lastY = 0;
        let downX = 0;
        let downY = 0;
        let downButton = 0;
        let pendingDx = 0;
        let pendingDy = 0;
        let dragRaf = 0;
        // Canvas-space last position for delta-based pan mode.
        let lastCanvasX = 0;
        let lastCanvasY = 0;

        // Kinetic panning (2D): track drag velocity and continue panning on release.
        let panVelX = 0; // px per ms
        let panVelY = 0; // px per ms
        let panLastT = 0;
        let panLastX = 0;
        let panLastY = 0;
        let panInertiaRaf = 0;
        let panInertiaLastT = 0;

        function cancelPanInertia() {
          if (panInertiaRaf) {
            try { window.cancelAnimationFrame(panInertiaRaf); } catch (e) {}
          }
          panInertiaRaf = 0;
          panInertiaLastT = 0;
          panVelX = 0;
          panVelY = 0;
        }

        function startPanInertia() {
          if (viewMode !== "2d") return;
          if (!wasm || !wasm.camera_pan) return;

          const speed = Math.hypot(panVelX, panVelY);
          if (speed < 0.02) return; // too slow to bother

          if (panInertiaRaf) cancelPanInertia();
          panInertiaLastT = performance.now();

          const tick = (t) => {
            const dt = Math.min(50, Math.max(0, t - panInertiaLastT));
            panInertiaLastT = t;

            // Exponential-ish decay to feel smooth across frame rates.
            const decay = Math.pow(0.90, dt / 16.666);
            panVelX *= decay;
            panVelY *= decay;

            const s = Math.hypot(panVelX, panVelY);
            if (s < 0.005) {
              panInertiaRaf = 0;
              return;
            }

            const dx = panVelX * dt;
            const dy = panVelY * dt;
            try {
              wasm.camera_pan(dx, dy);
              updateCompass();
            } catch (err) {
              // If wasm is mid-reload, just stop.
              panInertiaRaf = 0;
              return;
            }
            panInertiaRaf = window.requestAnimationFrame(tick);
          };

          panInertiaRaf = window.requestAnimationFrame(tick);
        }

        // Touch pinch-zoom support (pointer events).
        const activePointers = new Map(); // pointerId -> { x, y, type }
        let pinching = false;
        let pinchLastDist = 0;

        function canvasXYFromClient(canvas, clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const w = rect.width || 1;
          const h = rect.height || 1;
          // Map to canvas pixel coordinates (matches wasm canvas sizing).
          const x = (clientX - rect.left) * (canvas.width / w);
          const y = (clientY - rect.top) * (canvas.height / h);
          return { x, y };
        }

        function getTouchPair() {
          const pts = [];
          for (const [id, p] of activePointers) {
            if (p && p.type === "touch") pts.push({ id, x: p.x, y: p.y });
          }
          return pts.slice(0, 2);
        }

        function dist2(a, b) {
          const dx = a.x - b.x;
          const dy = a.y - b.y;
          return dx * dx + dy * dy;
        }

        function onPointerDown(e) {
          markUserInput();
          const canvas = activeCanvas();
          canvas.setPointerCapture(e.pointerId);

          // Any new interaction cancels inertia.
          cancelPanInertia();

          if (e.pointerType === "touch") {
            // Track touch pointers for pinch.
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: "touch" });
            const pts = getTouchPair();
            if (pts.length === 2) {
              pinching = true;
              dragging = false;
              pinchLastDist = Math.sqrt(dist2(pts[0], pts[1]));
              return;
            }
          }

          dragging = true;
          lastX = e.clientX;
          lastY = e.clientY;
          downX = e.clientX;
          downY = e.clientY;
          downButton = e.button;

          // If a mode is locked, use it; otherwise: left=orbit, right/shift=pan.
          if (lockMode === "pan") {
            dragMode = "pan";
          } else if (lockMode === "orbit") {
            dragMode = "orbit";
          } else if (e.button === 2 || e.shiftKey) {
            dragMode = "pan";
          } else {
            dragMode = "orbit";
          }

          // Arcball-style grab-to-rotate (and 2D pan) initialization.
          try {
            const { x, y } = canvasXYFromClient(canvas, e.clientX, e.clientY);
            lastCanvasX = x;
            lastCanvasY = y;
            if (viewMode === "2d") {
              panLastT = performance.now();
              panLastX = x;
              panLastY = y;
              panVelX = 0;
              panVelY = 0;
            }
            // Pass mouse button (0=left, 1=middle, 2=right) for globe controller
            if (wasm.camera_drag_begin_with_button) {
              wasm.camera_drag_begin_with_button(x, y, e.button);
            } else {
              wasm.camera_drag_begin(x, y);
            }
          } catch (err) {
            // ignore
          }
        }

        function onPointerMove(e) {
          // Mark input continuously while dragging/pinching so loaders back off.
          if (dragging || pinching) markUserInput();
          if (e.pointerType === "touch") {
            activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY, type: "touch" });
            const pts = getTouchPair();
            if (pinching && pts.length === 2) {
              // Convert pinch distance changes into wheel-like deltas.
              const dist = Math.sqrt(dist2(pts[0], pts[1]));
              const delta = pinchLastDist - dist;
              pinchLastDist = dist;
              // Scale to feel reasonable; negative delta => pinch out => zoom in.
              const wheelLike = delta * 2.0;
              try {
                if (viewMode === "2d" && wasm.camera_zoom_at) {
                  const canvas = activeCanvas();
                  const midClientX = (pts[0].x + pts[1].x) * 0.5;
                  const midClientY = (pts[0].y + pts[1].y) * 0.5;
                  const { x, y } = canvasXYFromClient(canvas, midClientX, midClientY);
                  wasm.camera_zoom_at(x, y, wheelLike);
                } else {
                  wasm.camera_zoom(wheelLike);
                }
                updateCompass();
              } catch (err) {
                console.error("pinch zoom failed", err);
              }
              return;
            }
          }

          // Cursor hover picking can be surprisingly expensive; throttle to one RAF.
          if (!dragging) {
            if (!window.__atlasCursorRaf) {
              const canvas = activeCanvas();
              const { x: ox, y: oy } = canvasXYFromClient(canvas, e.clientX, e.clientY);
              window.__atlasCursorRaf = window.requestAnimationFrame(() => {
                window.__atlasCursorRaf = 0;
                try {
                  const info = wasm.cursor_move(ox, oy);
                  if (info && info.hit) {
                    cursorText.textContent = `Cursor: lon ${info.lon.toFixed(4)}°, lat ${info.lat.toFixed(4)}°`;
                  } else {
                    cursorText.textContent = "Cursor: —";
                  }
                } catch (err) {
                  // ignore
                }
              });
            }
          }
          if (!dragging) return;

          // Update 2D pan velocity estimate for kinetic panning.
          if (viewMode === "2d" && !pinching) {
            const canvas = activeCanvas();
            const { x, y } = canvasXYFromClient(canvas, e.clientX, e.clientY);
            const now = performance.now();
            const dt = now - (panLastT || now);
            if (dt > 0 && dt < 100) {
              const vx = (x - panLastX) / dt;
              const vy = (y - panLastY) / dt;
              // Low-pass filter to reduce jitter.
              panVelX = panVelX * 0.75 + vx * 0.25;
              panVelY = panVelY * 0.75 + vy * 0.25;
            }
            panLastT = now;
            panLastX = x;
            panLastY = y;
          }

          // Coalesce moves into one RAF.
          {
            const canvas = activeCanvas();
            const { x, y } = canvasXYFromClient(canvas, e.clientX, e.clientY);
            pendingDx = x;
            pendingDy = y;
          }

          if (!dragRaf) {
            dragRaf = window.requestAnimationFrame(() => {
              dragRaf = 0;
              const px = pendingDx;
              const py = pendingDy;
              try {
                // Both modes use delta-based input.
                const dx = px - lastCanvasX;
                const dy = py - lastCanvasY;
                lastCanvasX = px;
                lastCanvasY = py;
                const buttons = typeof e.buttons === "number" ? e.buttons : 0;
                let mode = dragMode;
                if (buttons & 2) {
                  mode = "pan";
                } else if (buttons & 1) {
                  mode = "orbit";
                }
                if (mode === "pan") {
                  wasm.camera_pan(dx, dy);
                } else {
                  // Delta orbit: surface follows cursor direction ("from outside").
                  wasm.camera_orbit(dx, dy);
                }
                updateCompass();
              } catch (err) {
                console.error("camera input failed", err);
              }
            });
          }
        }

        function stopDrag() {
          dragging = false;
          pinching = false;
          activePointers.clear();

          panLastT = 0;

          try {
            wasm.camera_drag_end();
          } catch (err) {
            // ignore
          }
        }
        function onPointerUp(e) {
          if (e.pointerType === "touch") {
            activePointers.delete(e.pointerId);
            const pts = getTouchPair();
            if (pts.length < 2) {
              pinching = false;
            }
            // Don't treat touch as click-to-pick.
            stopDrag();
            return;
          }

          // If it was a click (not a drag), run picking.
          const dx = e.clientX - downX;
          const dy = e.clientY - downY;
          const dist2 = dx * dx + dy * dy;
          if (downButton === 0 && dist2 < 16) {
            try {
              const canvas = activeCanvas();
              const { x, y } = canvasXYFromClient(canvas, e.clientX, e.clientY);
              const picked = wasm.cursor_click(x, y);
              if (picked && picked.picked) {
                const kind = picked.kind ? String(picked.kind) : "feature";
                pickText.textContent = `Pick (${kind}): lon ${picked.lon.toFixed(4)}°, lat ${picked.lat.toFixed(4)}°`;
              } else {
                pickText.textContent = "Pick: —";
              }
            } catch (err) {
              console.error("pick failed", err);
            }
            stopDrag();
            return;
          }

          // End drag, then allow kinetic pan to continue (2D only).
          stopDrag();
          startPanInertia();
        }

        function onWheel(e) {
          e.preventDefault();
          markUserInput();
          cancelPanInertia();
          // Wheel events can fire at very high rates; smooth them over a few RAFs.
          const canvas = activeCanvas();
          const { x, y } = canvasXYFromClient(canvas, e.clientX, e.clientY);
          window.__atlasWheelTargetX = x;
          window.__atlasWheelTargetY = y;
          window.__atlasWheelVel = (window.__atlasWheelVel || 0) + e.deltaY;

          if (!window.__atlasWheelRaf) {
            const tick = () => {
              const v = window.__atlasWheelVel || 0;
              // Stop when velocity is tiny.
              if (Math.abs(v) < 0.05) {
                window.__atlasWheelVel = 0;
                window.__atlasWheelRaf = 0;
                return;
              }

              // Apply a fraction each frame and decay (critically damped-ish feel).
              const dy = v * 0.35;
              window.__atlasWheelVel = v - dy;

              try {
                if (viewMode === "2d" && wasm.camera_zoom_at) {
                  wasm.camera_zoom_at(window.__atlasWheelTargetX || 0, window.__atlasWheelTargetY || 0, dy);
                } else {
                  wasm.camera_zoom(dy);
                }
                updateCompass();
              } catch (err) {
                console.error("camera_zoom failed", err);
              }
              window.__atlasWheelRaf = window.requestAnimationFrame(tick);
            };
            window.__atlasWheelRaf = window.requestAnimationFrame(tick);
          }
        }

        for (const c of [canvas2d, canvas3d]) {
          c.addEventListener("pointerdown", onPointerDown);
          c.addEventListener("pointermove", onPointerMove);
          c.addEventListener("pointerup", onPointerUp);
          c.addEventListener("pointercancel", stopDrag);
          c.addEventListener("pointerleave", stopDrag);
          c.addEventListener("wheel", onWheel, { passive: false });
        }

        window.addEventListener("keydown", (e) => {
          if (e.key === "r" || e.key === "R") {
            try {
              wasm.camera_reset();
              updateCompass();
            } catch (err) {
              console.error("camera_reset failed", err);
            }
          }
        });

        function syncMapToggles() {
          mapGraticule?.classList.toggle("active", !!toggleGraticule.checked);
          mapSun?.classList.toggle("active", !!toggleRealSun.checked);
          if (lockMode === "auto") mapMode.textContent = "Auto";
          if (lockMode === "orbit") mapMode.textContent = "Orbit";
          if (lockMode === "pan") mapMode.textContent = "Pan";
        }

        mapHome?.addEventListener("click", () => {
          try { wasm.camera_reset(); updateCompass(); } catch (err) { console.error("camera_reset failed", err); }
        });
        mapZoomIn?.addEventListener("click", () => {
          try { wasm.camera_zoom(-180); } catch (err) { console.error("camera_zoom failed", err); }
        });
        mapZoomOut?.addEventListener("click", () => {
          try { wasm.camera_zoom(180); } catch (err) { console.error("camera_zoom failed", err); }
        });
        mapMode?.addEventListener("click", () => {
          lockMode = lockMode === "auto" ? "orbit" : lockMode === "orbit" ? "pan" : "auto";
          syncMapToggles();
        });
        mapGraticule?.addEventListener("click", () => {
          toggleGraticule.checked = !toggleGraticule.checked;
          toggleGraticule.dispatchEvent(new Event("change"));
          syncMapToggles();
        });
        mapSun?.addEventListener("click", () => {
          toggleRealSun.checked = !toggleRealSun.checked;
          toggleRealSun.dispatchEvent(new Event("change"));
          syncMapToggles();
        });
        mapHelp?.addEventListener("click", () => {
          aboutModal?.classList.remove("hidden");
        });
        aboutModalClose?.addEventListener("click", () => {
          aboutModal?.classList.add("hidden");
        });
        aboutModalOk?.addEventListener("click", () => {
          aboutModal?.classList.add("hidden");
        });
        // Close about modal when clicking outside
        aboutModal?.addEventListener("click", (e) => {
          if (e.target === aboutModal) {
            aboutModal.classList.add("hidden");
          }
        });

        fileGeoJson.addEventListener("change", async () => {
          const file = fileGeoJson.files && fileGeoJson.files[0];
          if (!file) return;

          const maxBytes = uploadSizeLimitMB * 1024 * 1024;
          if (file.size > maxBytes) {
            setStatus(`Upload too large (max ${uploadSizeLimitMB}MB): ${file.name}`);
            setUploadedInfo({
              error: `Upload too large (max ${uploadSizeLimitMB}MB). File is ${(file.size / 1024 / 1024).toFixed(1)}MB.`,
            });
            // allow re-uploading the same file
            fileGeoJson.value = "";
            return;
          }

          try {
            setStatus(`Loading ${file.name}…`);
            const text = await file.text();

            // Preflight in JS to avoid trapping the wasm module on overly complex GeoJSON.
            // This is intentionally conservative; the web viewer isn't meant for massive uploads.
            const MAX_FEATURES = 20_000;
            const currentMaxCoords = maxCoordPairs;
            try {
              const geo = JSON.parse(text);
              if (geo && geo.type === "FeatureCollection" && Array.isArray(geo.features)) {
                let coordPairs = 0;

                function countPoint(pt) {
                  if (Array.isArray(pt) && pt.length >= 2) coordPairs += 1;
                }
                function countLine(line) {
                  if (!Array.isArray(line)) return;
                  for (const pt of line) countPoint(pt);
                }
                function countPolygon(poly) {
                  if (!Array.isArray(poly)) return;
                  for (const ring of poly) countLine(ring);
                }
                function countGeometry(g) {
                  if (!g || typeof g !== "object") return;
                  const t = g.type;
                  const c = g.coordinates;
                  if (t === "Point") countPoint(c);
                  else if (t === "MultiPoint") {
                    if (Array.isArray(c)) for (const pt of c) countPoint(pt);
                  } else if (t === "LineString") countLine(c);
                  else if (t === "MultiLineString") {
                    if (Array.isArray(c)) for (const line of c) countLine(line);
                  } else if (t === "Polygon") countPolygon(c);
                  else if (t === "MultiPolygon") {
                    if (Array.isArray(c)) for (const poly of c) countPolygon(poly);
                  } else if (t === "GeometryCollection") {
                    if (Array.isArray(g.geometries)) for (const gg of g.geometries) countGeometry(gg);
                  }
                }

                if (geo.features.length > MAX_FEATURES) {
                  throw new Error(`Too many features (${geo.features.length}). Max is ${MAX_FEATURES}.`);
                }

                for (const f of geo.features) {
                  countGeometry(f && f.geometry);
                  if (coordPairs > currentMaxCoords) {
                    throw new Error(
                      `Too many coordinates (${coordPairs}). Max is ${currentMaxCoords.toLocaleString()}.`
                    );
                  }
                }
              }
            } catch (preflightErr) {
              // If JSON parses but is too large/complex, stop before calling wasm.
              // If JSON is invalid, we also stop here with a clearer error.
              setStatus(`Upload rejected: ${file.name}`);
              setUploadedInfo({
                error: preflightErr?.message ?? String(preflightErr),
              });
              return;
            }

            const summary = await wasm.load_geojson_file(file.name, text, uploadSizeLimitMB);

            // Refresh catalog (upload is persisted in AVC form when it fits local storage).
            renderCatalog();

            setUploadedInfo({
              name: summary?.name ?? file.name,
              points: summary?.points ?? 0,
              lines: summary?.lines ?? 0,
              polygons: summary?.polygons ?? 0,
              catalog_persisted: summary?.catalog_persisted,
              catalog_error: summary?.catalog_error,
            });

            // Enable uploaded layers (if present) and label them.
            layerUploadedPointsLabel.textContent = `Uploaded points (${file.name})`;
            layerUploadedCorridorsLabel.textContent = `Uploaded lines (${file.name})`;
            layerUploadedRegionsLabel.textContent = `Uploaded polygons (${file.name})`;
            layerUploadedPoints.checked = (summary?.points ?? 0) > 0;
            layerUploadedCorridors.checked = (summary?.lines ?? 0) > 0;
            layerUploadedRegions.checked = (summary?.polygons ?? 0) > 0;

            if (summary?.catalog_persisted) {
              setStatus(`Uploaded & saved: ${file.name}`);
            } else {
              setStatus(`Uploaded (not saved to Catalog): ${file.name}`);
            }
          } catch (err) {
            console.error("GeoJSON upload failed", err);
            setStatus("Upload failed (see console)");
            setUploadedInfo({ error: err?.message ?? String(err) });
          } finally {
            // allow re-uploading the same file
            fileGeoJson.value = "";
          }
        });

        toggleGraticule.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_graticule_enabled(enabled);
          } catch (err) {
            console.error("set_graticule_enabled failed", err);
          }
          syncMapToggles();
        });

        toggleRealSun.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_real_time_sun_enabled(enabled);
          } catch (err) {
            console.error("set_real_time_sun_enabled failed", err);
          }
          syncMapToggles();
        });

        if (wasm.get_auto_rotate_settings) {
          try {
            const settings = wasm.get_auto_rotate_settings();
            if (settings) {
              if (toggleAutoRotate) toggleAutoRotate.checked = !!settings.enabled;
              if (autoRotateSpeed && settings.speed_deg_per_s !== undefined) {
                autoRotateSpeed.value = String(settings.speed_deg_per_s);
              }
              if (autoRotateSpeedValue && settings.speed_deg_per_s !== undefined) {
                autoRotateSpeedValue.textContent = Number(settings.speed_deg_per_s).toFixed(4);
              }
            }
          } catch (err) {
            console.error("get_auto_rotate_settings failed", err);
          }
        }

        toggleAutoRotate?.addEventListener("change", (e) => {
          const enabled = !!e.target.checked;
          try {
            wasm.set_auto_rotate_enabled(enabled);
          } catch (err) {
            console.error("set_auto_rotate_enabled failed", err);
          }
        });

        autoRotateSpeed?.addEventListener("input", (e) => {
          const v = Number(e.target.value);
          if (autoRotateSpeedValue) autoRotateSpeedValue.textContent = v.toFixed(4);
          try {
            wasm.set_auto_rotate_speed_deg_per_s(v);
          } catch (err) {
            console.error("set_auto_rotate_speed_deg_per_s failed", err);
          }
        });

        // Upload size limit setting
        const uploadSizeLimit = document.getElementById("upload-size-limit");
        const uploadSizeLimitValue = document.getElementById("upload-size-limit-value");
        if (uploadSizeLimit) {
          uploadSizeLimit.value = String(uploadSizeLimitMB);
          if (uploadSizeLimitValue) uploadSizeLimitValue.textContent = String(uploadSizeLimitMB);

          uploadSizeLimit.addEventListener("input", (e) => {
            const v = Math.max(1, Math.min(MAX_UPLOAD_SIZE_MB_LIMIT, Math.round(Number(e.target.value))));
            uploadSizeLimitMB = v;
            if (uploadSizeLimitValue) uploadSizeLimitValue.textContent = String(v);
            try { localStorage.setItem("atlas.uploadSizeMB", String(v)); } catch (_) {}
          });
        }

        // Max coordinates limit setting
        const maxCoordPairsSlider = document.getElementById("max-coord-pairs");
        const maxCoordPairsValue = document.getElementById("max-coord-pairs-value");
        if (maxCoordPairsSlider) {
          const initialK = Math.round(maxCoordPairs / 1000);
          maxCoordPairsSlider.value = String(initialK);
          if (maxCoordPairsValue) maxCoordPairsValue.textContent = `${initialK}k`;

          maxCoordPairsSlider.addEventListener("input", (e) => {
            const k = Math.max(100, Math.min(10000, Math.round(Number(e.target.value))));
            maxCoordPairs = k * 1000;
            if (maxCoordPairsValue) maxCoordPairsValue.textContent = `${k}k`;
            try { localStorage.setItem("atlas.maxCoordPairs", String(maxCoordPairs)); } catch (_) {}
          });
        }

        // ── Controls settings wiring ──────────────────────────────
        {
          const sliders = [
            { id: "ctrl-orbit-sens", key: "orbit_sensitivity" },
            { id: "ctrl-pan-sens-3d", key: "pan_sensitivity_3d" },
            { id: "ctrl-zoom-speed-3d", key: "zoom_speed_3d" },
            { id: "ctrl-pan-sens-2d", key: "pan_sensitivity_2d" },
            { id: "ctrl-zoom-speed-2d", key: "zoom_speed_2d" },
          ];
          const checkboxes = [
            { id: "ctrl-invert-orbit-y", key: "invert_orbit_y" },
            { id: "ctrl-invert-pan-y-3d", key: "invert_pan_y_3d" },
            { id: "ctrl-invert-pan-y-2d", key: "invert_pan_y_2d" },
            { id: "ctrl-kinetic-pan", key: "kinetic_panning" },
          ];

          // Load saved control config from localStorage
          function loadControlConfig() {
            try {
              const saved = localStorage.getItem("atlas.controlConfig");
              if (saved) return JSON.parse(saved);
            } catch (_) {}
            return null;
          }

          function saveControlConfig() {
            try {
              const json = wasm.get_control_config ? wasm.get_control_config() : null;
              if (json) localStorage.setItem("atlas.controlConfig", json);
            } catch (_) {}
          }

          function syncControlsUI() {
            try {
              const cfg = JSON.parse(wasm.get_control_config());
              for (const { id, key } of sliders) {
                const el = document.getElementById(id);
                const val = document.getElementById(id + "-value");
                if (el && cfg[key] !== undefined) {
                  el.value = String(cfg[key]);
                  if (val) val.textContent = Number(cfg[key]).toFixed(1);
                }
              }
              for (const { id, key } of checkboxes) {
                const el = document.getElementById(id);
                if (el && cfg[key] !== undefined) el.checked = cfg[key];
              }
            } catch (_) {}
          }

          // Apply saved config on load
          const savedCfg = loadControlConfig();
          if (savedCfg && wasm.set_control_config) {
            for (const [key, value] of Object.entries(savedCfg)) {
              try {
                const numVal = typeof value === "boolean" ? (value ? 1 : 0) : Number(value);
                wasm.set_control_config(key, numVal);
              } catch (_) {}
            }
          }
          syncControlsUI();

          // Wire slider inputs
          for (const { id, key } of sliders) {
            const el = document.getElementById(id);
            const val = document.getElementById(id + "-value");
            if (!el) continue;
            el.addEventListener("input", () => {
              const v = Number(el.value);
              if (val) val.textContent = v.toFixed(1);
              try { wasm.set_control_config(key, v); } catch (_) {}
              saveControlConfig();
            });
          }

          // Wire checkbox inputs
          for (const { id, key } of checkboxes) {
            const el = document.getElementById(id);
            if (!el) continue;
            el.addEventListener("change", () => {
              try { wasm.set_control_config(key, el.checked ? 1 : 0); } catch (_) {}
              saveControlConfig();
            });
          }

          // Reset button
          const resetBtn = document.getElementById("ctrl-reset-defaults");
          if (resetBtn) {
            resetBtn.addEventListener("click", () => {
              try {
                wasm.reset_control_config();
                syncControlsUI();
                saveControlConfig();
              } catch (err) { console.error("reset_control_config failed", err); }
            });
          }
        }

        function applyCitySize() {
          const v = Number(citySize.value);
          citySizeValue.textContent = String(v);
          try {
            wasm.set_city_marker_size(v);
          } catch (err) {
            console.error("set_city_marker_size failed", err);
          }
        }

        function applyLineWidth() {
          const v = Number(lineWidth.value);
          lineWidthValue.textContent = String(v);
          try {
            wasm.set_line_width_px(v);
          } catch (err) {
            console.error("set_line_width_px failed", err);
          }
        }

        citySize.addEventListener("input", applyCitySize);
        // Apply once at startup to sync wasm state.
        applyCitySize();

        lineWidth.addEventListener("input", applyLineWidth);
        applyLineWidth();

        syncMapToggles();

        // Panel toggle and resize functionality
        const PANEL_DEFAULT_WIDTH = 320;
        const PANEL_MIN_WIDTH = 280;
        const PANEL_MAX_WIDTH = 600;
        const PANEL_COLLAPSED_WIDTH = 52;
        
        const panel = document.getElementById("side-panel");
        const panelToggle = document.getElementById("panel-toggle");
        const resizeHandle = document.getElementById("panel-resize-handle");
        const app = document.getElementById("app");

        // Load saved panel state from localStorage
        const savedWidth = localStorage.getItem("panel-width");
        const savedCollapsed = localStorage.getItem("panel-collapsed") === "true";
        
        if (savedCollapsed) {
          panel.classList.add("collapsed");
          panelToggle.textContent = "▶";
          panelToggle.title = "Expand panel";
          app.style.setProperty("--panel-width", PANEL_COLLAPSED_WIDTH + "px");
        } else if (savedWidth) {
          app.style.setProperty("--panel-width", savedWidth + "px");
        } else {
          // Set default width explicitly for consistency
          app.style.setProperty("--panel-width", PANEL_DEFAULT_WIDTH + "px");
        }

        // Toggle panel collapse/expand
        panelToggle.addEventListener("click", () => {
          const isCollapsed = panel.classList.toggle("collapsed");
          panelToggle.textContent = isCollapsed ? "▶" : "◀";
          panelToggle.title = isCollapsed ? "Expand panel" : "Collapse panel";
          
          if (isCollapsed) {
            app.style.setProperty("--panel-width", PANEL_COLLAPSED_WIDTH + "px");
            localStorage.setItem("panel-collapsed", "true");
          } else {
            // Get the most recent width from localStorage
            const currentSavedWidth = localStorage.getItem("panel-width");
            const width = currentSavedWidth || PANEL_DEFAULT_WIDTH;
            app.style.setProperty("--panel-width", width + "px");
            localStorage.setItem("panel-collapsed", "false");
          }
          
          resizeCanvas(wasm);
        });

        // Resize functionality
        let isResizing = false;
        let startX = 0;
        let startWidth = 0;

        const onMouseMove = (e) => {
          if (!isResizing) return;
          const delta = e.clientX - startX;
          const newWidth = Math.max(PANEL_MIN_WIDTH, Math.min(PANEL_MAX_WIDTH, startWidth + delta));
          app.style.setProperty("--panel-width", newWidth + "px");
        };

        const onMouseUp = () => {
          if (!isResizing) return;
          isResizing = false;
          resizeHandle.classList.remove("resizing");
          // Save the new width and resize canvas once
          const currentWidth = panel.offsetWidth;
          if (currentWidth > 0) {
            localStorage.setItem("panel-width", currentWidth.toString());
          }
          resizeCanvas(wasm);
          // Remove listeners to avoid unnecessary event handling
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };

        resizeHandle.addEventListener("mousedown", (e) => {
          if (panel.classList.contains("collapsed")) return;
          isResizing = true;
          startX = e.clientX;
          startWidth = panel.offsetWidth;
          resizeHandle.classList.add("resizing");
          e.preventDefault();
          // Add listeners only when resizing
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        });

        setStatus("Controls: drag=rotate, wheel=zoom, R=reset, click=pick");

        // Default view mode.
        applyViewMode(viewMode);
      }

      // ═══════════════════════════════════════════════════════════
      // ▸ Time Dial – scrollable timeline with playback controls
      // ═══════════════════════════════════════════════════════════

      // ── IndexedDB persistence ──────────────────────────────────
      const TD_DB_NAME = "atlas-time-settings";
      const TD_DB_VERSION = 1;
      const TD_STORE = "settings";

      function tdOpenDb() {
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(TD_DB_NAME, TD_DB_VERSION);
          req.onupgradeneeded = () => {
            const db = req.result;
            if (!db.objectStoreNames.contains(TD_STORE)) {
              db.createObjectStore(TD_STORE);
            }
          };
          req.onsuccess = () => resolve(req.result);
          req.onerror = () => reject(req.error);
        });
      }

      async function tdSaveSettings(settings) {
        try {
          const db = await tdOpenDb();
          const tx = db.transaction(TD_STORE, "readwrite");
          tx.objectStore(TD_STORE).put(settings, "current");
          await new Promise((res, rej) => { tx.oncomplete = res; tx.onerror = rej; });
          db.close();
        } catch (e) {
          console.warn("tdSaveSettings failed, falling back to localStorage", e);
          try { localStorage.setItem("atlas-time-settings", JSON.stringify(settings)); } catch (_) {}
        }
      }

      async function tdLoadSettings() {
        try {
          const db = await tdOpenDb();
          const tx = db.transaction(TD_STORE, "readonly");
          const req = tx.objectStore(TD_STORE).get("current");
          const result = await new Promise((res, rej) => { req.onsuccess = () => res(req.result); req.onerror = rej; });
          db.close();
          if (result) return result;
        } catch (e) {
          console.warn("tdLoadSettings from IDB failed", e);
        }
        // Fallback: localStorage
        try {
          const raw = localStorage.getItem("atlas-time-settings");
          if (raw) return JSON.parse(raw);
        } catch (_) {}
        return null;
      }

      // ── Default settings ────────────────────────────────────────
      function tdDefaults() {
        return {
          mode: "relative",       // "relative" | "absolute"
          speed: 1,
          startTime: 0,
          endTime: 10,
          stepSize: 1/60,         // ~16ms per frame
          loopMode: "loop",       // "loop" | "once" | "bounce"
          format: "wallclock",      // "wallclock" | "seconds" | "hms" | "datetime"
          tickInterval: 1,
          showDial: true,
          layerTimeConfig: {},    // { layerName: { enabled: bool, field: string } }
        };
      }

      // ── Wire it all up ──────────────────────────────────────────
      function wireTimeDial(wasm) {
        const dial      = document.getElementById("time-dial");
        const canvas    = document.getElementById("td-canvas");
        const wrapper   = document.getElementById("td-track-wrapper");
        const label     = document.getElementById("td-label");
        const speedLabel = document.getElementById("td-speed");
        const playBtn   = document.getElementById("td-play");
        const stepBack  = document.getElementById("td-step-back");
        const stepFwd   = document.getElementById("td-step-fwd");
        const settingsBtn = document.getElementById("td-settings-btn");

        // Settings modal elements
        const modal     = document.getElementById("time-settings-modal");
        const modalClose = document.getElementById("ts-modal-close");
        const tsMode    = document.getElementById("ts-mode");
        const tsSpeed   = document.getElementById("ts-speed");
        const tsStart   = document.getElementById("ts-start");
        const tsEnd     = document.getElementById("ts-end");
        const tsStep    = document.getElementById("ts-step");
        const tsLoop    = document.getElementById("ts-loop");
        const tsFormat  = document.getElementById("ts-format");
        const tsDivisions = document.getElementById("ts-divisions");
        const tsShowDial = document.getElementById("ts-show-dial");
        const tsLayerList = document.getElementById("ts-layer-list");
        const tsResetBtn = document.getElementById("ts-reset-btn");
        const tsSaveBtn = document.getElementById("ts-save-btn");

        // Settings panel toggle (in the left panel Settings tab)
        const panelDialToggle = document.getElementById("toggle-time-dial");

        if (!dial || !canvas || !wrapper) return;

        const ctx = canvas.getContext("2d");
        let settings = tdDefaults();

        // Helper: sync the panel toggle checkbox + dial visibility
        function syncDialVisibility() {
          dial.classList.toggle("hidden", !settings.showDial);
          if (panelDialToggle) panelDialToggle.checked = settings.showDial;
        }

        // Playback state
        let playing = false;
        let playDirection = 1; // 1=forward, -1=backward (for bounce)
        let dragStartX = null;
        let dragStartTime = null;

        // ── Format helpers ────────────────────────────────────────
        function formatTime(t) {
          if (settings.format === "wallclock") {
            const now = new Date();
            // Offset from "now" by the engine time difference
            const d = new Date(now.getTime());
            const hh = String(d.getHours()).padStart(2, "0");
            const mm = String(d.getMinutes()).padStart(2, "0");
            const ss = String(d.getSeconds()).padStart(2, "0");
            return `${hh}:${mm}:${ss}`;
          }
          if (settings.format === "hms") {
            const neg = t < 0;
            const abs = Math.abs(t);
            const h = Math.floor(abs / 3600);
            const m = Math.floor((abs % 3600) / 60);
            const s = Math.floor(abs % 60);
            const ms = Math.round((abs % 1) * 100);
            const hms = `${String(h).padStart(2, "0")}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
            return (neg ? "-" : "") + (ms > 0 ? `${hms}.${String(ms).padStart(2, "0")}` : hms);
          }
          if (settings.format === "datetime") {
            // epoch-ms offset from an origin (Jan 1 2020 for now)
            const origin = new Date("2020-01-01T00:00:00Z").getTime();
            const d = new Date(origin + t * 1000);
            return d.toISOString().replace("T", " ").replace("Z", "").slice(0, 19);
          }
          // seconds
          return t.toFixed(2) + "s";
        }

        function shortFormatTime(t) {
          if (settings.format === "wallclock") {
            const now = new Date();
            const offsetSec = t - (wasm.get_time ? wasm.get_time() : 0);
            const d = new Date(now.getTime() + offsetSec * 1000);
            const hh = String(d.getHours()).padStart(2, "0");
            const mm = String(d.getMinutes()).padStart(2, "0");
            return `${hh}:${mm}`;
          }
          if (settings.format === "hms") {
            const abs = Math.abs(t);
            const m = Math.floor(abs / 60);
            const s = Math.floor(abs % 60);
            return `${m}:${String(s).padStart(2, "0")}`;
          }
          if (settings.format === "datetime") {
            const origin = new Date("2020-01-01T00:00:00Z").getTime();
            const d = new Date(origin + t * 1000);
            return `${String(d.getUTCHours()).padStart(2,"0")}:${String(d.getUTCMinutes()).padStart(2,"0")}`;
          }
          return t.toFixed(1);
        }

        // ── Draw the tick track ──────────────────────────────────
        function drawTrack() {
          const dpr = window.devicePixelRatio || 1;
          const rect = wrapper.getBoundingClientRect();
          const w = rect.width;
          const h = rect.height;
          canvas.width = Math.round(w * dpr);
          canvas.height = Math.round(h * dpr);
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          ctx.clearRect(0, 0, w, h);

          const currentTime = wasm.get_time ? wasm.get_time() : 0;
          const interval = Math.max(0.1, settings.tickInterval);
          const centerX = w / 2;

          // Pixels per second – scale so ~10 ticks are visible
          const pxPerSec = w / (interval * 10);

          // Compute CSS color from theme
          const fg = getComputedStyle(document.documentElement).getPropertyValue("--fg").trim() || "#e2e8f0";
          const muted = getComputedStyle(document.documentElement).getPropertyValue("--muted").trim() || "#94a3b8";
          const accent = getComputedStyle(document.documentElement).getPropertyValue("--accent-border").trim() || "#3b82f6";

          // Find first visible tick
          const visibleHalf = w / 2;
          const tMin = currentTime - visibleHalf / pxPerSec;
          const tMax = currentTime + visibleHalf / pxPerSec;
          const firstTick = Math.floor(tMin / interval) * interval;

          ctx.lineWidth = 1;
          for (let t = firstTick; t <= tMax + interval; t += interval) {
            const x = centerX + (t - currentTime) * pxPerSec;
            if (x < -10 || x > w + 10) continue;

            // Major tick every 5 intervals, minor in between
            const isMajor = Math.abs(Math.round(t / interval)) % 5 === 0;
            const tickH = isMajor ? h * 0.55 : h * 0.30;

            ctx.strokeStyle = isMajor ? fg : muted;
            ctx.globalAlpha = isMajor ? 0.5 : 0.25;
            ctx.beginPath();
            ctx.moveTo(x, (h - tickH) / 2);
            ctx.lineTo(x, (h + tickH) / 2);
            ctx.stroke();

            // Label for major ticks
            if (isMajor) {
              ctx.globalAlpha = 0.6;
              ctx.fillStyle = muted;
              ctx.font = "9px Inter, system-ui, sans-serif";
              ctx.textAlign = "center";
              ctx.fillText(shortFormatTime(t), x, h - 4);
            }
          }

          // Range indicators (start/end boundaries)
          const startX = centerX + (settings.startTime - currentTime) * pxPerSec;
          const endX = centerX + (settings.endTime - currentTime) * pxPerSec;

          ctx.globalAlpha = 0.12;
          ctx.fillStyle = accent;
          if (startX > 0) {
            ctx.fillRect(0, 0, startX, h);
          }
          if (endX < w) {
            ctx.fillRect(endX, 0, w - endX, h);
          }

          ctx.globalAlpha = 1;
          // Update label
          label.textContent = formatTime(currentTime);
        }

        // ── Playback controls ─────────────────────────────────────
        function setPlaying(p) {
          playing = p;
          playBtn.textContent = playing ? "⏸" : "▶";
          playBtn.classList.toggle("active", playing);
        }

        playBtn.addEventListener("click", () => setPlaying(!playing));

        stepBack.addEventListener("click", () => {
          setPlaying(false);
          const t = (wasm.get_time ? wasm.get_time() : 0) - settings.tickInterval;
          const clamped = Math.max(settings.startTime, t);
          try { wasm.set_time(clamped); } catch (e) { console.error(e); }
          drawTrack();
        });

        stepFwd.addEventListener("click", () => {
          setPlaying(false);
          const t = (wasm.get_time ? wasm.get_time() : 0) + settings.tickInterval;
          const clamped = Math.min(settings.endTime, t);
          try { wasm.set_time(clamped); } catch (e) { console.error(e); }
          drawTrack();
        });

        // Playback loop: advance time when playing
        let lastPlayTick = 0;
        function playbackTick(now) {
          if (playing) {
            const dt = lastPlayTick ? (now - lastPlayTick) / 1000 : 0;
            lastPlayTick = now;
            if (dt > 0 && dt < 0.5) {
              let t = (wasm.get_time ? wasm.get_time() : 0) + dt * settings.speed * playDirection;

              if (settings.loopMode === "loop") {
                if (t > settings.endTime) t = settings.startTime;
                if (t < settings.startTime) t = settings.endTime;
              } else if (settings.loopMode === "once") {
                if (t > settings.endTime) { t = settings.endTime; setPlaying(false); }
                if (t < settings.startTime) { t = settings.startTime; setPlaying(false); }
              } else if (settings.loopMode === "bounce") {
                if (t > settings.endTime) { t = settings.endTime; playDirection = -1; }
                if (t < settings.startTime) { t = settings.startTime; playDirection = 1; }
              }

              try { wasm.set_time(t); } catch (e) { console.error(e); }
            }
          } else {
            lastPlayTick = 0;
          }
          drawTrack();
          requestAnimationFrame(playbackTick);
        }
        requestAnimationFrame(playbackTick);

        // ── Drag scrolling ────────────────────────────────────────
        function getPxPerSec() {
          const rect = wrapper.getBoundingClientRect();
          return rect.width / (Math.max(0.1, settings.tickInterval) * 10);
        }

        wrapper.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          wrapper.setPointerCapture(e.pointerId);
          dragStartX = e.clientX;
          dragStartTime = wasm.get_time ? wasm.get_time() : 0;
          setPlaying(false);
        });

        wrapper.addEventListener("pointermove", (e) => {
          if (dragStartX === null) return;
          const dx = e.clientX - dragStartX;
          const pxPerSec = getPxPerSec();
          const dt = -dx / pxPerSec;
          const t = Math.max(settings.startTime, Math.min(settings.endTime, dragStartTime + dt));
          try { wasm.set_time(t); } catch (err) { console.error(err); }
          drawTrack();
        });

        wrapper.addEventListener("pointerup", () => { dragStartX = null; });
        wrapper.addEventListener("pointercancel", () => { dragStartX = null; });

        // Wheel scroll
        wrapper.addEventListener("wheel", (e) => {
          e.preventDefault();
          const pxPerSec = getPxPerSec();
          const dt = (e.deltaY > 0 ? 1 : -1) * settings.tickInterval;
          const t = (wasm.get_time ? wasm.get_time() : 0) + dt;
          const clamped = Math.max(settings.startTime, Math.min(settings.endTime, t));
          try { wasm.set_time(clamped); } catch (err) { console.error(err); }
          drawTrack();
        }, { passive: false });

        // Resize
        window.addEventListener("resize", () => drawTrack());

        // ── Settings modal ────────────────────────────────────────
        function openSettings() {
          // Populate modal from current settings
          tsMode.value = settings.mode;
          tsSpeed.value = String(settings.speed);
          tsStart.value = String(settings.startTime);
          tsEnd.value = String(settings.endTime);
          tsStep.value = String(settings.stepSize);
          tsLoop.value = settings.loopMode;
          tsFormat.value = settings.format;
          tsDivisions.value = String(settings.tickInterval);
          tsShowDial.checked = settings.showDial;
          populateLayerTimeList();
          modal.classList.remove("hidden");
        }

        function closeSettings() {
          modal.classList.add("hidden");
        }

        settingsBtn.addEventListener("click", openSettings);
        modalClose.addEventListener("click", closeSettings);
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeSettings();
        });

        // ── Layer time configuration ─────────────────────────────
        function getLayerNames() {
          // Collect known layer names from the UI checkboxes
          const names = [];
          const knownLayers = [
            { id: "layer-world-base", name: "World base" },
            { id: "layer-cities", name: "Cities" },
            { id: "layer-corridors", name: "Air corridors" },
            { id: "layer-regions", name: "Regions" },
            { id: "layer-uploaded-points", name: "Uploaded points" },
            { id: "layer-uploaded-corridors", name: "Uploaded lines" },
            { id: "layer-uploaded-regions", name: "Uploaded polygons" },
            { id: "layer-terrain", name: "3D terrain" },
          ];
          for (const l of knownLayers) {
            names.push(l.name);
          }
          // Also include feed layers
          const feedControls = document.getElementById("feed-layer-controls");
          if (feedControls) {
            const feedLabels = feedControls.querySelectorAll("label span");
            for (const el of feedLabels) {
              const n = el.textContent?.trim();
              if (n) names.push("Feed: " + n);
            }
          }
          return names;
        }

        function populateLayerTimeList() {
          const layers = getLayerNames();
          if (layers.length === 0) {
            tsLayerList.innerHTML = '<div class="muted" style="font-size:12px;">No layers loaded yet.</div>';
            return;
          }
          tsLayerList.innerHTML = "";
          for (const name of layers) {
            const cfg = settings.layerTimeConfig[name] || { enabled: false, field: "timestamp" };
            const row = document.createElement("div");
            row.className = "layer-time-row";

            const cb = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = cfg.enabled;
            cb.dataset.layer = name;
            cb.className = "lt-checkbox";

            const lbl = document.createElement("span");
            lbl.className = "lt-name";
            lbl.textContent = name;

            const field = document.createElement("input");
            field.type = "text";
            field.placeholder = "timestamp";
            field.value = cfg.field || "timestamp";
            field.dataset.layer = name;
            field.className = "lt-field";
            field.style.maxWidth = "130px";
            field.style.padding = "4px 6px";
            field.style.borderRadius = "4px";
            field.style.border = "1px solid var(--btn-border)";
            field.style.background = "var(--btn-bg)";
            field.style.color = "var(--btn-fg)";
            field.style.fontSize = "12px";

            row.appendChild(cb);
            row.appendChild(lbl);
            row.appendChild(field);
            tsLayerList.appendChild(row);
          }
        }

        // ── Save / load settings ─────────────────────────────────
        function applySettings(s) {
          settings = { ...tdDefaults(), ...s };
          // Sync to engine
          try { wasm.set_time_end?.(settings.endTime); } catch (_) {}
          try { wasm.set_dt?.(settings.stepSize); } catch (_) {}
          speedLabel.textContent = settings.speed + "×";
          syncDialVisibility();
          playDirection = 1;
          drawTrack();
        }

        async function saveAndApply() {
          // Read from modal inputs
          settings.mode = tsMode.value;
          settings.speed = parseFloat(tsSpeed.value) || 1;
          settings.startTime = parseFloat(tsStart.value) || 0;
          settings.endTime = parseFloat(tsEnd.value) || 10;
          settings.stepSize = parseFloat(tsStep.value) || 1/60;
          settings.loopMode = tsLoop.value;
          settings.format = tsFormat.value;
          settings.tickInterval = parseFloat(tsDivisions.value) || 1;
          settings.showDial = tsShowDial.checked;

          // Read layer time config
          const checkboxes = tsLayerList.querySelectorAll(".lt-checkbox");
          const fields = tsLayerList.querySelectorAll(".lt-field");
          settings.layerTimeConfig = {};
          checkboxes.forEach((cb) => {
            const name = cb.dataset.layer;
            const fieldEl = tsLayerList.querySelector(`.lt-field[data-layer="${CSS.escape(name)}"]`);
            settings.layerTimeConfig[name] = {
              enabled: cb.checked,
              field: fieldEl ? fieldEl.value.trim() || "timestamp" : "timestamp",
            };
          });

          applySettings(settings);
          await tdSaveSettings(settings);
          closeSettings();
        }

        tsSaveBtn.addEventListener("click", saveAndApply);

        tsResetBtn.addEventListener("click", async () => {
          const def = tdDefaults();
          applySettings(def);
          await tdSaveSettings(def);
          openSettings();
        });

        // Keyboard shortcut: T to toggle dial visibility
        window.addEventListener("keydown", (e) => {
          if (e.target.tagName === "INPUT" || e.target.tagName === "SELECT" || e.target.tagName === "TEXTAREA") return;
          if (e.key === "t" || e.key === "T") {
            settings.showDial = !settings.showDial;
            syncDialVisibility();
            tdSaveSettings(settings).catch(() => {});
          }
          if (e.key === " " && e.target === document.body) {
            e.preventDefault();
            setPlaying(!playing);
          }
        });

        // Left-panel Settings tab toggle
        if (panelDialToggle) {
          panelDialToggle.addEventListener("change", () => {
            settings.showDial = panelDialToggle.checked;
            syncDialVisibility();
            tdSaveSettings(settings).catch(() => {});
          });
        }

        // ── Init: load persisted settings ─────────────────────────
        tdLoadSettings().then((saved) => {
          if (saved) {
            applySettings(saved);
          } else {
            // Sync defaults from engine
            settings.endTime = wasm.get_time_end ? wasm.get_time_end() : 10;
            settings.stepSize = wasm.get_dt ? wasm.get_dt() : 1/60;
            applySettings(settings);
          }
        }).catch(() => {
          applySettings(settings);
        });
      }

      function bootstrap() {
        const alreadyLoaded = window.wasmBindings;
        if (alreadyLoaded) {
          main(alreadyLoaded).catch((e) => console.error("main failed", e));
          return;
        }

        window.addEventListener("TrunkApplicationStarted", () => {
          if (!window.wasmBindings) {
            console.error("Trunk started but wasmBindings missing");
            return;
          }
          main(window.wasmBindings).catch((e) => console.error("main failed", e));
        });
      }

      bootstrap();
    </script>
  </body>
</html>
